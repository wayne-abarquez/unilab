(function () {
    'use strict';

    angular
        .module('demoApp.sales', [])

        .constant('SALES_TRANSACTION_TYPES', ['CLIENT VISIT', 'GAS', 'FLIGHT'])
        .constant('BRANCH_TYPES', ['MDC', 'LKA', 'GT'])

    ;

}());

(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('territoryInfoPanelController', ['$rootScope', 'branchService', 'placesService', '$mdSidenav', territoryInfoPanelController]);

    function territoryInfoPanelController ($rootScope, branchService, placesService, $mdSidenav) {
        var vm = this;

        vm.showPOIByType = showPOIByType;
        vm.toggleBranches = toggleBranches;
        vm.close = close;

        initialize();

        function initialize () {
            $rootScope.$on('territory_selected', function (e, data) {
                vm.territory = angular.copy(data);

                if (!vm.territory.places) return;

                var allPlaces = [];
                for (var k in vm.territory.places) {
                    vm.territory.places[k].forEach(function (item) {
                        allPlaces.push(item);
                    });
                }
                vm.territory.places['all'] = allPlaces;
            });

            $rootScope.$on('close-territory-info-panel', function(){
               close();
            });
        }

        function showPOIByType (type) {
            placesService.showPOIByType(type);
        }

        function toggleBranches () {
            branchService.toggleMarkers();
        }

        function close () {
            //$rootScope.showGRDPPanel = false;

            $mdSidenav('territoryInfoPanelSidenav')
                .close()
                .then(function () {
                    $rootScope.showTerritoryDetailBtn = true;
                });
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp.sales')
        .factory('Territory', ['Restangular', Territory]);

    function Territory(Restangular) {
        var myModel = Restangular.all('territories');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'territories');
            }
        };

        Restangular.extendModel('territories', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function() {
    'use strict';

    angular.module('demoApp.sales')
        .factory('salesTransactionService', ['$rootScope', 'SalesTransaction', 'userSessionService', '$q', 'gmapServices', 'MARKER_BASE_URL', 'Sellout', salesTransactionService]);

    function salesTransactionService($rootScope, SalesTransaction, userSessionService, $q, gmapServices, MARKER_BASE_URL, Sellout) {
        var service = {};

        var transactionTypes = {
            'CLIENT VISIT': {
                markerIcon: 'insurance-agency',
                color: '#f39c12',
                icon: 'store'
            },
            'GAS': {
                markerIcon: 'gas-station',
                color: '#e67e22',
                icon: 'local_gas_station'
            },
            'FLIGHT': {
                markerIcon: 'airport',
                color: '#16a085',
                icon: 'flight_takeoff'
            },

            'COVERAGE': {
                markerIcon: 'embassy',
                color: '#e67e22',
                icon: 'flag'
            },
            '1SS': {
                markerIcon: 'atm',
                color: '#3498db',
                icon: 'local_atm'
            },
            'C3S': {
                markerIcon: 'bank',
                color: '#9b59b6',
                icon: 'account_balance'
            },
            'IIDACS': {
                markerIcon: 'finance',
                color: '#3498db',
                icon: 'finance'
            },
            'FLEET': {
                markerIcon: 'taxi-stand',
                color: '#e74c3c',
                icon: 'local_taxi'
            }
        };

        var iconByStatus = {
            'CLEARED': 'transaction-default.png',
            'FRAUD': 'transaction-fraud.png',
            'INVESTIGATING': 'transaction-investigate.png'
        };

        var marker,
        transactionMarkerItem = null,
            infowindow = null,
            inviMarker,
            transactionMarkers = [],
            inviMarkers = [],
            transactionList = [];

        var labels = {
            nextTransaction: null,
            previousTransaction: null
        };

        var nextTransactionDirectionsDisplay,
        previousTransactionDirectionsDisplay;

        service.saveTransaction = saveTransaction;
        service.getUserTransactions = getUserTransactions;
        service.showTransactionOnMap = showTransactionOnMap;
        service.initMarkers = initMarkers;
        service.showMarkers = showMarkers;
        service.hideMarkers = hideMarkers;
        service.getIconByType = getIconByType;
        service.showMarkerById = showMarkerById;
        service.getTransactionById = getTransactionById;
        service.updateTransactionStatus = updateTransactionStatus;
        service.resetMarkers = resetMarkers;
        service.resetTransactionVisuals = resetTransactionVisuals;
        service.saveTransactionRemarks = saveTransactionRemarks;
        service.getSelloutDistinctDates = getSelloutDistinctDates;

        function saveTransactionRemarks(transactionId, remarks) {
            var dfd = $q.defer();

            var restObj = SalesTransaction.cast(transactionId);

            restObj.customPUT({
                'remarks': remarks
            })
                .then(function(response) {

                var foundIndex = _.findIndex(transactionMarkers, {
                    id: transactionId
                });

                if (foundIndex > -1) {
                    transactionMarkers[foundIndex].remarks = remarks;
                    transactionMarkers[foundIndex].marker.transaction.remarks = remarks;
                    transactionMarkers[foundIndex].marker.content = setInfowindowContent(transactionMarkers[foundIndex], transactionMarkers[foundIndex].marker);
                }

                dfd.resolve(response.plain());
            }, function(error) {
                dfd.reject(error);
            });

            return dfd.promise;
        }

        function updateTransactionStatus(id, status) {
            var dfd = $q.defer();

            var restObj = SalesTransaction.cast(id);

            restObj.customPUT({
                'status': status
            })
                .then(function(response) {

                var transaction = getTransactionById(id);

                if (!transaction) return;

                transaction.status = status;

                transaction.marker.setIcon(getMarkerIconByStatus(transaction.status));

                setInfowindowContent(transaction, transaction.marker);
                infowindow.setContent(transaction.marker.content);

                dfd.resolve(response.plain());
            }, function(error) {
                dfd.reject(error);
            });

            return dfd.promise;
        }

        function getTransactionById(transactionId) {
            return _.findWhere(transactionMarkers, {
                id: transactionId
            });
        }

        function showMarkers() {
            transactionMarkerItem.setMap(null);

            transactionMarkers.forEach(function(item) {
                if (item.marker && !item.marker.getMap()) {
                    item.marker.setMap(gmapServices.map);
                }
            });
        }

        function hideMarkers() {
            transactionMarkers.forEach(function(item) {
                if (item.marker && item.marker.getMap()) {
                    item.marker.setMap(null);
                }
            });
        }

        var icon;

        function getIconByType(type) {
            var type = transactionTypes[type.toUpperCase()];

            return type ? type : transactionTypes[Object.keys(transactionTypes)[0]];
        }

        function getMarkerIconByStatus(status) {
            if (!status) return MARKER_BASE_URL + 'transaction-default.png';

            return MARKER_BASE_URL + iconByStatus[status.toUpperCase()];
        }

        function createMarker(latlng, item, isFromFraud) {
            icon = getMarkerIconByStatus(item.status);
            marker = gmapServices.initMarker(latlng, icon);
            if (!isFromFraud) marker.setMap(null);
            return marker;
        }

        function setInfowindowContent(item, marker, index) {
            marker.content = '<div>';
            //marker.content += '<p class="no-margin text-muted padding-left-5"><b>Employee: </b> ' + 'Randy Ambito' + '</p>';
            marker.content += '<p class="no-margin text-muted padding-left-5"><b>Transaction Type: </b> ' + (item.type ? item.type : '') + '</p>';
            marker.content += '<p class="no-margin text-muted padding-left-5"><b>Status: </b> ' + (item.status ? item.status : '') + '</p>';

            if (item.merchant && item.merchant.name) {
                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Merchant Name: </b>' + item.merchant.name + '</p>';
                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Merchant Address: </b>' + item.merchant.address + '</p>';
            }

            marker.content += '<p class="no-margin text-muted padding-left-5"><b>Description: </b> ' + (item.description ? item.description : '') + '</p>';
            marker.content += '<p class="no-margin text-muted padding-left-5"><b>Amount: </b> ' + (item.cost ? item.cost : '') + '</p>';
            marker.content += '<p class="no-margin text-muted padding-left-5"><b>Transaction Date: </b> ' + (item.transaction_date_formatted ? item.transaction_date_formatted : '') + '</p>';

            marker.content += '<br>';

            if (item.average_travel_time_in_minutes && item.travel_distance_in_km) {
                marker.content += '<p class="no-margin text-muted padding-left-5" style="color:#f39c12;"><b>Previous Transaction</b></p>';
                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Actual Travel Time: </b> ' + (item.travel_time_in_minutes ? item.travel_time_in_minutes + ' mins' : '') + '</p>';
                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Average Travel Time: </b> ' + (item.average_travel_time_in_minutes ? item.average_travel_time_in_minutes + ' mins' : '') + '</p>';
                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Distance: </b> ' + (item.travel_distance_in_km ? item.travel_distance_in_km + ' km' : '') + '</p>';

                var prevTravelDiff = Math.abs(item.travel_time_in_minutes - item.average_travel_time_in_minutes);

                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Difference: </b> ' + (item.travel_time_in_minutes && item.average_travel_time_in_minutes ? prevTravelDiff.toFixed(2) + ' mins' : '') + '</p>';

                marker.content += '<br>';
            }

            if (item.next_average_travel_time_in_minutes && item.next_travel_distance_in_km) {
                marker.content += '<p class="no-margin text-muted padding-left-5" style="color:#27ae60;"><b>Next Transaction</b></p>';

                if (transactionList.length > 1 && index < transactionList.length - 1) {
                    marker.content += '<p class="no-margin text-muted padding-left-5"><b>Actual Travel Time: </b> ' + (transactionList[index + 1].travel_time_in_minutes ? transactionList[index + 1].travel_time_in_minutes + ' mins' : '') + '</p>';
                }

                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Average Travel Time: </b> ' + (item.next_average_travel_time_in_minutes ? item.next_average_travel_time_in_minutes + ' mins' : '') + '</p>';
                marker.content += '<p class="no-margin text-muted padding-left-5"><b>Distance: </b> ' + (item.next_travel_distance_in_km ? item.next_travel_distance_in_km + ' km' : '') + '</p>';

                if (transactionList.length > 1 && index < transactionList.length - 1) {
                    var nextTravelDiff = Math.abs(transactionList[index + 1].travel_time_in_minutes - transactionList[index + 1].average_travel_time_in_minutes);
                    marker.content += '<p class="no-margin text-muted padding-left-5"><b>Difference: </b> ' + (transactionList[index + 1].travel_time_in_minutes && transactionList[index + 1].average_travel_time_in_minutes ? nextTravelDiff.toFixed(2) + ' mins' : '') + '</p>';
                }

                marker.content += '<br>';
            }

            //marker.content += '<br>';

            marker.content += '<p class="no-margin text-muted padding-left-5">(Note: Difference = Average Travel Time vs Actual Travel Time)</p>';
            marker.content += '<br>';


            marker.content += '<label class="text-muted"  style="padding:0.5rem 0 0 0.5rem;"><b>Validation Remarks: </b></label>';
            marker.content += '<textarea class="textarea" id="transaction-remarks-textarea" data-transaction-id="' + item.id + '"rows="2" cols="20" placeholder="Enter validation remarks here...">' + (item.remarks ? item.remarks : '') + '</textarea>'
            marker.content += '<div class="transaction-remarks-textarea-container"><span id="transaction-remarks-textarea-response" class="label label-success"></span></div>';

            if (item.status != 'FRAUD') marker.content += '<button id="mark-fraud-btn" data-transaction-id="' + item.id + '" class="md-button md-raised md-warn">Fraud</button>';
            if (item.status != 'CLEARED') marker.content += '<button id="mark-cleared-btn" data-transaction-id="' + item.id + '" class="md-button md-raised md-default">Cleared</button>';
            if (item.status != 'INVESTIGATING' || !item.status) marker.content += '<button id="mark-investigate-btn" data-transaction-id="' + item.id + '" class="md-button md-raised md-accent">Investigate</button>';

            marker.content += '</div>';

            return marker.content;
        }

        function createContentForInfowindow(item, marker, index) {
            setInfowindowContent(item, marker, index);

            marker.transaction = angular.copy(item);

            gmapServices.addListener(marker, 'click', function() {
                clearMapLabel();

                infowindow.open(gmapServices.map, this);
                infowindow.setContent(this.content);

                showTransactionOnMap(this.transaction, true);
                showNextTransaction(this.transaction);

                $('#fraud-panel md-list.transaction-list md-list-item').removeClass('focused-material-list-item');

                var container = $('body .fraud-list-content'),
                    scrollTo = $('#fraud-panel md-list.transaction-list md-list-item#transaction-' + this.transaction.id);

                scrollTo.addClass('focused-material-list-item');

                var scrollToValue = scrollTo.offset().top - container.offset().top + container.scrollTop();

                container.animate({
                    scrollTop: scrollToValue
                }, 1500);
            });
        }

        function getTransactionWithSameDay(transactionDate) {
            return transactionMarkers.map(function(item) {
                if (item.transaction_date.substring(0, 10) == transactionDate.substring(0, 10)) return item;
            });
        }

        function showNextTransaction(transaction) {
            var sameDateTransactions = getTransactionWithSameDay(transaction.transaction_date);

            if (!sameDateTransactions.length) return;

            var currentIndex = _.findIndex(sameDateTransactions, {
                id: transaction.id
            });

            if (currentIndex === -1) return;

            // next route
            if (currentIndex < sameDateTransactions.length - 1) {
                var nextTransaction = sameDateTransactions[currentIndex + 1];
                // show next transaction
                gmapServices.initializeDirectionsService();
                if (!nextTransactionDirectionsDisplay || !nextTransactionDirectionsDisplay.getMap()) {
                    nextTransactionDirectionsDisplay = gmapServices.initializeIndividualDirectionsRenderer({
                        draggable: false,
                        preserveViewport: true,
                        suppressMarkers: true,
                        polylineOptions: {
                            strokeOpacity: 0.75,
                            strokeColor: '#27ae60',
                            map: gmapServices.map
                        }
                    });
                }

                labels.nextTransaction = {
                    'test': 'test'
                };

                var travelInfo = {
                    distance: transaction.travel_distance_in_km,
                    duration: transaction.travel_time_in_minutes
                };

                calculateAndDisplayRoute(transaction.end_point_latlng, nextTransaction.end_point_latlng, travelInfo, labels.nextTransaction, nextTransactionDirectionsDisplay, 'Next', 'rgba(39, 174, 96, 0.75)')
                    .then(function(label) {
                    labels.nextTransaction = label;
                });
            } else console.log('transaction ' + transaction.id + ' is last transaction of the day.');

            // previous route
            if (currentIndex > 0) {
                var previousTransaction = sameDateTransactions[currentIndex - 1];
                // show next transaction
                gmapServices.initializeDirectionsService();
                if (!previousTransactionDirectionsDisplay || !previousTransactionDirectionsDisplay.getMap()) {
                    previousTransactionDirectionsDisplay = gmapServices.initializeIndividualDirectionsRenderer({
                        draggable: false,
                        preserveViewport: true,
                        suppressMarkers: true,
                        polylineOptions: {
                            strokeOpacity: 0.75,
                            strokeColor: '#f39c12',
                            map: gmapServices.map
                        }
                    });
                }

                labels.previousTransaction = {
                    'test': 'test'
                };

                var travelInfo = {
                    distance: transaction.next_travel_distance_in_km,
                    duration: transaction.next_average_travel_time_in_minutes
                };

                calculateAndDisplayRoute(previousTransaction.end_point_latlng, transaction.end_point_latlng, travelInfo, labels.previousTransaction, previousTransactionDirectionsDisplay, 'Prev', 'rgba(243, 156, 18, 0.75)')
                    .then(function(label) {
                    labels.previousTransaction = label;
                });
            } else console.log('transaction ' + transaction.id + ' is first transaction of the day.');
        }

        function addTransaction(item, isFromFraud, index) {
            var obj = angular.copy(item);

            if (item.end_point_latlng) {
                obj.marker = createMarker(item.end_point_latlng, item, isFromFraud);
            } else if (item.start_point_latlng) {
                obj.marker = createMarker(item.start_point_latlng, item, isFromFraud);
            }

            obj.marker.id = item.id;

            if (obj.marker) createContentForInfowindow(item, obj.marker, index);

            return obj;
        }

        function clearMapLabel() {
            for (var key in labels) {
                if (!_.isEmpty(labels[key]) && labels[key] instanceof google.maps.OverlayView) {
                    labels[key].setMap(null);
                    labels[key] = null;
                }
            }

            inviMarkers.forEach(function(marker) {
                if (marker && marker.getMap()) {
                    marker.setMap(null);
                    marker = null;
                }
            });

            inviMarkers = [];
        }

        function resetTransactionVisuals() {
            if (gmapServices.directionsDisplay) gmapServices.directionsDisplay.setDirections({
                routes: []
            });
            if (previousTransactionDirectionsDisplay) previousTransactionDirectionsDisplay.setDirections({
                routes: []
            });
            if (nextTransactionDirectionsDisplay) nextTransactionDirectionsDisplay.setDirections({
                routes: []
            });

            clearMapLabel();

            if (infowindow) infowindow.close();
        }

        function resetMarkers() {
            resetTransactionVisuals();

            transactionMarkers.forEach(function(obj) {
                if (obj && obj.marker && obj.marker.getMap()) {
                    obj.marker.setMap(null);
                }
            });
            transactionMarkers = [];
        }

        function initMarkers(list, isFromFraud) {
            if (!infowindow) infowindow = gmapServices.createInfoWindow('', {
                zIndex: 1
            });

            transactionList = angular.copy(list);

            transactionMarkers = list.map(function(item, idx) {
                return addTransaction(item, isFromFraud, idx);
            });

            //transactionMarkers = [];
            //list.forEach(function(item,idx){
            //    if (!_.isEmpty(item.end_point_latlng) || !_.isEmpty(item.start_point_latlng)) {
            //        transactionMarkers.push(addTransaction(item, isFromFraud, idx));
            //    }
            //});

            var mapLegendData = getMapLegendData(list);

            $rootScope.$broadcast('compile-map-legend', {
                type: 'transactions',
                data: mapLegendData
            });

            return transactionMarkers;
        }

        function getMapLegendData(list) {
            return _.pluck(_.uniq(list, function(item) {
                return item.status;
            }), 'status').map(function(stat) {
                if (stat) return {
                    name: stat,
                    iconUrl: getMarkerIconByStatus(stat)
                };
            });
        }

        function saveTransaction(data, id) {
            var dfd = $q.defer();

            if (id) { // update
                var restObj = SalesTransaction.cast(id);
                restObj.customPUT(data)
                    .then(function(response) {
                    dfd.resolve(response.plain());
                }, function(error) {
                    dfd.reject(error);
                });
            } else { // insert
                SalesTransaction.post(data)
                    .then(function(response) {
                    var resp = response.plain();
                    var transactionItem = addTransaction(resp.sales_transaction);
                        //if (transactionItem) return;
                    gmapServices.showMarker(transactionItem.marker);
                    transactionMarkers.push(transactionItem);
                    dfd.resolve(resp);
                }, function(error) {
                    dfd.reject(error);
                });
            }

            return dfd.promise;
        }

        function getIconColorByStatus(status) {
            if (!status) return '#95a5a6';

            switch (status.toUpperCase()) {
                case 'CLEARED':
                    return '#2ecc71';
                case 'FRAUD':
                    return '#e74c3c';
                case 'INVESTIGATING':
                    return '#f39c12';
            }
        }

        function getUserTransactions(pageNo, pageSize) {
            var dfd = $q.defer();

            var user = userSessionService.getUserInfo(true);

            if (user) {
                user.getList('salestransactions', {
                    page_no: pageNo,
                    page_size: pageSize
                })
                    .then(function(response) {
                    dfd.resolve(response.plain().map(function(item) {
                        item.icon = transactionTypes[item.type.toUpperCase()];
                        item.icon.color = getIconColorByStatus(item.status);
                        return item;
                    }));
                }, function(error) {
                    dfd.reject(error);
                });
            } else {
                dfd.reject();
            }

            return dfd.promise;
        }

        function getCenterOfRouteResult(routes) {
            var route = routes[0];

            var center = route.overview_path[Math.floor(route.overview_path.length / 2)];

            if (center) return center;

            return route.overview_path[Math.floor(route.overview_path.length / 2 - 1)];
        }

        function calculateAndDisplayRoute(originLatlng, destinationLatLng, travelInfo, customInfoLabel, customDirectionsDisplay, labelStartText, labelBgColor) {
            var dfd = $q.defer();

            gmapServices.directionsService.route({
                origin: originLatlng,
                destination: destinationLatLng,
                travelMode: 'DRIVING'
            }, function(response, status) {
                if (status === 'OK') {
                    if (customDirectionsDisplay) customDirectionsDisplay.setDirections(response);
                    else gmapServices.directionsDisplay.setDirections(response);

                    if (!_.isEmpty(customInfoLabel)) {
                        var contentStr = 'to next transaction';

                        var center = getCenterOfRouteResult(response.routes);

                        var invimarker = gmapServices.initMarker(center, null, {
                            visible: false
                        })

                        if (!travelInfo.distance || !travelInfo.duration) {
                            gmapServices.initializeDistanceMatrix();

                            console.log('CALLING DISTANCE MATRIX');
                            gmapServices.distanceMatrix.getDistanceMatrix({
                                origins: [originLatlng],
                                destinations: [destinationLatLng],
                                travelMode: 'DRIVING',
                                newForwardGeocoder: true
                            }, function(response, status) {

                                if (status == 'OK' && response.rows.length && response.rows[0].elements.length) {
                                    contentStr = '';
                                    if (labelStartText) contentStr += labelStartText + ' | ';
                                    contentStr += 'Distance: ' + response.rows[0].elements[0].distance.text;
                                    contentStr += ' | Average Travel Time: ' + response.rows[0].elements[0].duration.text;
                                    customInfoLabel = new Label({
                                        map: gmapServices.map,
                                        text: contentStr,
                                        bgcolor: labelBgColor
                                    });
                                    customInfoLabel.bindTo('position', invimarker, 'position');
                                    inviMarkers.push(invimarker);
                                    dfd.resolve(customInfoLabel);
                                }
                            });
                        } else {
                            contentStr = '';
                            if (labelStartText) contentStr += labelStartText + ' | ';
                            contentStr += 'Distance: ' + travelInfo.distance;
                            contentStr += ' | Average Travel Time: ' + travelInfo.duration;

                            customInfoLabel = new Label({
                                map: gmapServices.map,
                                text: contentStr,
                                bgcolor: labelBgColor
                            });
                            customInfoLabel.bindTo('position', invimarker, 'position');
                            inviMarkers.push(invimarker);
                            dfd.resolve(customInfoLabel);
                        }

                    } else dfd.reject();

                } else {
                    dfd.reject();
                    console.log('Directions request failed due to ' + status);
                }
            });

            return dfd.promise;
        }

        function showTransactionOnMap(transaction, isFromFraud) {
            //console.log('showTransactionOnMap: ', transaction);
            if (nextTransactionDirectionsDisplay) nextTransactionDirectionsDisplay.setDirections({
                routes: []
            });
            if (previousTransactionDirectionsDisplay) previousTransactionDirectionsDisplay.setDirections({
                routes: []
            });

            if (!transaction.start_point_latlng && transaction.end_point_latlng && !isFromFraud) {
                // show marker
                if (transactionMarkerItem) {
                    transactionMarkerItem.setMap(null);
                }

                transactionMarkerItem = createMarker(transaction.end_point_latlng, transaction.type);
                transactionMarkerItem.setMap(gmapServices.map);

                gmapServices.setZoomIfGreater(15);
                gmapServices.panTo(transaction.end_point_latlng);
            }
        }

        function showMarkerById(id) {
            var found = _.findWhere(transactionMarkers, {
                id: id
            });
            if (found && found.marker) {
                if (!found.marker.getMap()) found.marker.setMap(gmapServices.map);

                // show infowindow
                gmapServices.triggerEvent(found.marker, 'click');
            }
        }

        function getSelloutDistinctDates () {
            var dfd = $q.defer();

            Sellout.getList({'distinct': 'dates'})
                .then(function(response){
                    dfd.resolve(_.pluck(response.plain(), 'sellout_date'));
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.sales')
        .factory('SalesTransaction', ['Restangular', SalesTransaction]);

    function SalesTransaction(Restangular) {
        var myModel = Restangular.all('salestransactions');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'salestransactions');
            }
        };

        Restangular.extendModel('salestransactions', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('salesPanelController', ['$q', '$scope', '$rootScope', 'userTerritoriesService', 'gmapServices', 'branchService', '$mdSidenav', 'placesService', '$timeout', 'alertServices', 'salesTransactionService', salesPanelController]);

    function salesPanelController ($q, $scope, $rootScope, userTerritoriesService, gmapServices, branchService, $mdSidenav, placesService, $timeout, alertServices, salesTransactionService) {
        var vm = this;

        var polygonTerritory;

        var foundTypeIndex,
            isSelected;

        vm.toggleTransactions = false;

        var selectedTypes = [];

        vm.territories = [];

        vm.filter = {
            q: '',
            qt: ''
        };

        vm.toggleToolbarPanel = toggleToolbarPanel;
        vm.showTerritoryDetails = showTerritoryDetails;
        vm.toggleType = toggleType;
        vm.toggleTransactionsDisplay = toggleTransactionsDisplay;
        vm.showTransaction = showTransaction;


        initialize();

        function initialize () {
            $rootScope.$watch('currentUser', function (newValue) {
                if (!newValue) return;

                userTerritoriesService.getTerritories()
                    .then(function (territories) {
                        vm.territories = angular.copy(territories);
                    });

                salesTransactionService.getUserTransactions()
                    .then(function(transactions){
                        vm.transactions = salesTransactionService.initMarkers(transactions);
                    });
                //vm.dynamicTransactions = new DynamicItems();
            });

            var rawTypes = placesService.getPlaceTypes().map(function (type) {
                foundTypeIndex = placesService.defaultPlaceTypes.indexOf(type);
                isSelected = false;

                // initially select default place type
                if (foundTypeIndex !== -1) {
                    selectedTypes.push(type);
                    isSelected = true;
                }

                return {
                    name: type,
                    model: isSelected
                }
            });

            vm.placeTypes = _.groupBy(rawTypes, function(item, index){
               return index % 2;
            });

            $scope.$watch(function () {
                return vm.loadPois;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;

                if (newValue) {
                    placesService.showVisiblePOIs();
                    return;
                }

                placesService.hidePOIs();
            });
        }

        function toggleToolbarPanel () {
            vm.filter.q = '';
            vm.showSalesTransactionsList = !vm.showSalesTransactionsList;
        }

        function showPolygonTerritory(latLngArray) {
            if (!latLngArray.length) {
                alertServices.showError('Cannot load polygon, data error.');
                return;
            }

            if (polygonTerritory) {
                polygonTerritory.setPath(latLngArray);
                return;
            }

            polygonTerritory = gmapServices.createPolygon(latLngArray, '#3f51b5');
            polygonTerritory.setVisible(false);
        }

        function toggleType(type) {
            var arr = vm.placeTypes['0'].concat(vm.placeTypes['1']);
            var val = _.findWhere(arr, {name: type});

            var index = selectedTypes.indexOf(val.name);

            if (val.model && index === -1) {
                selectedTypes.push(val.name)
            } else if (index !== -1) {
                selectedTypes.splice(index, 1);
            }
        }

        function toggleTransactionsDisplay (flag) {
            if (flag) {
                // show transaction markers
                salesTransactionService.showMarkers();
            } else {
                // hide
                salesTransactionService.hideMarkers();
                gmapServices.hideDirectionsRenderer();
            }
        }

        function showTerritoryDetails (item) {
            $rootScope.$broadcast('clear-compare-branches');

            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').show();

            $rootScope.selectedTerritory = item;

            branchService.hideMarkers();
            placesService.hidePOIs();

            showPolygonTerritory(item.territory.geom);

            gmapServices.setZoomIfGreater(12);
            gmapServices.panToPolygon(polygonTerritory);

            var promises = [];

            // load places
            if (vm.loadPois) {
                console.log('selected place types: ', selectedTypes);
                promises.push(
                    placesService.loadPOIs(item.territoryid, selectedTypes)
                        .then(function (response) {
                            placesService.showPOIs(response);
                            $rootScope.selectedTerritory.places = response;
                        })
                );
            }

            promises.push(
                userTerritoriesService.getTerritoryBranches(item.territoryid)
                    .then(function (response) {
                        $rootScope.selectedTerritory.branches = response;

                        if (!response.length) {
                            alertServices.showBottomLeftToast('This territory doesnt have branch yet.');
                        } else {
                            branchService.loadMarkers(response);
                        }

                        $timeout(function () {
                            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
                        }, 500);

                        $mdSidenav('territoryInfoPanelSidenav').open();
                        $rootScope.$broadcast('territory_selected', $rootScope.selectedTerritory);
                    })
            );

            //$q.all([promises])
            //    .finally(function(){
            //        $timeout(function () {
            //            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
            //        }, 1000);
            //    });
        }

        function showTransaction (item) {
            console.log('showTransaction: ',item);
            salesTransactionService.showTransactionOnMap(item);
        }


        /* DYNAMIC ITEMS */

        // In this example, we set up our model using a class.
        // Using a plain object works too. All that matters
        // is that we implement getItemAtIndex and getLength.
        //var DynamicItems = function () {
        //    /**
        //     * @type {!Object<?Array>} Data pages, keyed by page number (0-index).
        //     */
        //    this.loadedPages = {};
        //
        //    /** @type {number} Total number of items. */
        //    this.numItems = 0;
        //
        //    /** @const {number} Number of items to fetch per request. */
        //    this.PAGE_SIZE = 50;
        //
        //    this.fetchNumItems_();
        //};
        //
        //// Required.
        //DynamicItems.prototype.getItemAtIndex = function (index) {
        //    console.log('DynamicItems getItemAtIndex',index);
        //    var pageNumber = Math.floor(index / this.PAGE_SIZE);
        //    var page = this.loadedPages[pageNumber];
        //
        //    if (page) {
        //        var item = page[index % this.PAGE_SIZE];
        //        console.log('page: ',page);
        //        return item;
        //    } else if (page !== null) {
        //        this.fetchPage_(pageNumber);
        //    }
        //};
        //
        //// Required.
        //DynamicItems.prototype.getLength = function () {
        //    return this.numItems;
        //};
        //
        //DynamicItems.prototype.fetchPage_ = function (pageNumber) {
        //    console.log('DynamicItems fetchPage_',pageNumber);
        //    // Set the page to null so we know it is already being fetched.
        //    this.loadedPages[pageNumber] = null;
        //
        //    var that = this;
        //    // For demo purposes, we simulate loading more items with a timed
        //    // promise. In real code, this function would likely contain an
        //    // $http request.
        //    salesTransactionService.getUserTransactions(pageNumber, this.PAGE_SIZE)
        //        .then(angular.bind(this, function(transactions){
        //
        //            that.loadedPages[pageNumber] = [];
        //
        //            transactions.forEach(function(item){
        //                that.loadedPages[pageNumber].push(item);
        //            });
        //        }));
        //};
        //
        //DynamicItems.prototype.fetchNumItems_ = function () {
        //    // For demo purposes, we simulate loading the item count with a timed
        //    // promise. In real code, this function would likely contain an
        //    // $http request.
        //    $timeout(angular.noop, 300).then(angular.bind(this, function () {
        //        this.numItems = 2000;
        //    }));
        //};














    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('salesPageController', ['$rootScope', 'gmapServices', 'modalServices', salesPageController]);

    function salesPageController ($rootScope, gmapServices, modalServices) {
        var vm = this;

        initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');

            $rootScope.$on('search-address-return-result', function (e, params) {
                if ($rootScope.hasOpenedModal) return;

                modalServices.showNewTransactionForm(e, params)
                    .finally(function () {
                        $rootScope.$broadcast('clear-search-address-bar');
                    });
            });
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('newTransactionController', ['param', '$scope', 'SALES_TRANSACTION_TYPES', 'MARKER_BASE_URL', 'modalServices', 'alertServices', 'gmapServices', 'formHelperService', '$timeout', 'salesTransactionService', newTransactionController]);

    function newTransactionController (param, $scope, SALES_TRANSACTION_TYPES, MARKER_BASE_URL, modalServices, alertServices, gmapServices, formHelperService, $timeout, salesTransactionService) {
        var vm = this;

        var result;
        var autocompleteResult

        var markers = {
          start: {
              marker: null,
              icon: MARKER_BASE_URL + 'start.png',
              dragendListener: null
          },
          end: {
              marker: null,
              icon: MARKER_BASE_URL + 'end.png',
              dragendListener: null
          }
        };

        var autocompletes = {
            start: {
                autocomplete: null,
                id: 'filter-starting-address-input',
                callback : null
            },
            end: {
                autocomplete: null,
                id: 'filter-destination-address-input',
                callback: null
            }
        };

        vm.transactionTypes = SALES_TRANSACTION_TYPES;
        vm.maxDate = new Date();

        vm.form = {};
        vm.transaction = {};

        vm.save = save;
        vm.close = close;

        initialize();

        function initialize () {
            if (param && param.result) {
                result = angular.copy(param.result);

                gmapServices.setZoomIfGreater(14);

                alertServices.showBottomLeftToast('Drag marker to point exact location.', 10000);

                vm.transaction.address = result.formatted_address;
                vm.transaction.end_point_address = result.formatted_address;
                createDestinationPointMarker(result.geometry.location);
            }

            gmapServices.initializeDirectionsService();
            gmapServices.initializeDirectionsRenderer({draggable: true});

            $timeout(function(){
                initializeAutocompletes();
            }, 1000);

            $scope.$watch(function(){
                return vm.transaction.start_point_latlng;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;

               if (newValue && vm.transaction.end_point_latlng) {
                   calculateAndDisplayRoute(newValue, vm.transaction.end_point_latlng);
               }
            });

            $scope.$watch(function () {
                return vm.transaction.end_point_latlng;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;

                if (newValue && vm.transaction.start_point_latlng) {
                    calculateAndDisplayRoute(vm.transaction.start_point_latlng, newValue);
                }
            });

            $scope.$on('$destroy', function () {
                cleanUp();
            });
        }

        function cleanUp() {
            vm.transaction = null;

            gmapServices.directionsService = null;
            gmapServices.directionsDisplay.setMap(null);
            gmapServices.directionsDisplay = null;

            for (var k in markers) {
                if (markers[k].marker && markers[k].marker.getMap()) {
                    markers[k].marker.setMap(null);
                    markers[k].marker = null;
                }
                if (markers[k].dragendListener) {
                    gmapServices.removeListener(markers[k].dragendListener);
                }
            }
        }

        function calculateAndDisplayRoute(originLatlng, destinationLatLng) {
            if (!gmapServices.directionsService || !gmapServices.directionsDisplay) return;

            gmapServices.directionsService.route({
                origin: originLatlng,
                destination: destinationLatLng,
                travelMode: 'DRIVING'
            }, function (response, status) {
                console.log('calculateAndDisplayRoute response: ', response);
                if (status === 'OK') {
                    gmapServices.directionsDisplay.setDirections(response);
                } else {
                    alertServices.showError('Directions request failed due to ' + status);
                }
            });
        }

        function placeChangeCallback(autocompleteObj) {
            var place = autocompleteObj.getPlace();

            if (!place.geometry) {
                alertServices.showInfo("Address not found.");
                return;
            }

            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }

            return place;
        }

        function createStartPointMarker (latlng) {
            markers.start.marker = gmapServices.initMarker(latlng, markers.start.icon, {draggable: true});
            vm.transaction.start_point_latlng = latlng.toJSON();

            markers.start.dragendListener = gmapServices.addListener(markers.start.marker, 'dragend', function (e) {
                vm.transaction.start_point_latlng = e.latLng.toJSON();
                // reverse geocode latlng
                gmapServices.reverseGeocode(e.latLng)
                    .then(function (result) {
                        if (result.length) vm.transaction.start_point_address = result[0].formatted_address;
                    });
            });
            return markers.start.marker;
        }

        function createDestinationPointMarker(latlng) {
            markers.end.marker = gmapServices.initMarker(latlng, markers.end.icon, {draggable: true});
            vm.transaction.end_point_latlng = latlng.toJSON();

            markers.end.dragendListener = gmapServices.addListener(markers.end.marker, 'dragend', function (e) {
                vm.transaction.end_point_latlng = e.latLng.toJSON();
                // reverse geocode latlng
                gmapServices.reverseGeocode(e.latLng)
                    .then(function (result) {
                        if (result.length) {
                            vm.transaction.end_point_address = result[0].formatted_address;
                            vm.transaction.address = result[0].formatted_address;
                        }
                    });
            });
            return markers.end.marker;
        }

        function setPlotMarkerLocation(latlng, markerInstance) {
            gmapServices.panTo(latlng);

            if (markerInstance && markerInstance.getMap()) {
                markerInstance.setOptions({
                    visible: true,
                    animation: google.maps.Animation.DROP,
                    position: latlng
                });
            }
        }

        function initializeAutocompletes () {
            autocompletes.start.callback = function () {
                autocompleteResult = placeChangeCallback(autocompletes.start.autocomplete);
                if (!markers.start.marker) createStartPointMarker(autocompleteResult.geometry.location);
                else setPlotMarkerLocation(autocompleteResult.geometry.location, markers.start.marker);
            };

            autocompletes.end.callback = function () {
                autocompleteResult = placeChangeCallback(autocompletes.end.autocomplete);

                if (!markers.end.marker) createDestinationPointMarker(autocompleteResult.geometry.location);
                else setPlotMarkerLocation(autocompleteResult.geometry.location, markers.end.marker);

                $scope.$apply(function () {
                    vm.transaction.address = angular.copy(autocompleteResult.formatted_address);
                });
            };

            for (var k in autocompletes) {
                autocompletes[k].autocomplete = gmapServices.initializeAutocomplete(autocompletes[k].id, {
                    componentRestrictions: {country: 'ph'}
                });
                autocompletes[k].autocomplete.addListener('place_changed', autocompletes[k].callback);
            }
        }

        function getFormData() {
            var formData = angular.copy(vm.transaction);

            formData.start_point_latlng = markers.start.marker.getPosition().toJSON();
            formData.end_point_latlng = markers.end.marker.getPosition().toJSON();

            return formData;
        }

        function save() {
            if (!vm.form.$valid) {
                formHelperService.showFormErrors(vm.form.$error);
                return;
            }

            if (!markers.start.marker) {
                vm.transaction.start_point_address = '';
                return;
            } else if (!markers.end.marker) {
                vm.transaction.end_point_address = '';
                return;
            }

            console.log('save transaction: ', vm.transaction);
            var formData = getFormData();
            console.log('formData: ', formData);

            // process send to backend
            salesTransactionService.saveTransaction(formData)
                .then(function (response) {
                    //console.log('save sales transaction: ',response);
                    alertServices.showSuccess('Transaction saved.');
                    modalServices.hideResolveModal(response);
                }, function (error) {
                    // show errors
                    alertServices.showError(formHelperService.getFormattedErrors(error.data));
                })
                .finally(function () {
                    // hide spinner
                });
        }

        function close () {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('newBranchController', ['param', '$scope', '$rootScope', 'BRANCH_TYPES', 'MARKER_BASE_URL', 'modalServices', 'alertServices', 'gmapServices', 'formHelperService', '$timeout', 'branchService', newBranchController]);

    function newBranchController (param, $scope, $rootScope, BRANCH_TYPES, MARKER_BASE_URL, modalServices, alertServices, gmapServices, formHelperService, $timeout, branchService) {
        var vm = this;

        var result;

        var plotMarker,
            markerUrl = MARKER_BASE_URL + 'default-marker.png',
            dragendListener;

        vm.branchTypes = BRANCH_TYPES;
        vm.maxDate = new Date();

        vm.form = {};
        vm.branch = {};

        vm.save = save;
        vm.setLocation = setLocation;
        vm.close = close;

        initialize();

        function initialize () {
            if (param && param.result) {
                result = angular.copy(param.result);

                plotMarker = createPlotMarker(result.geometry.location);
                gmapServices.setZoomIfGreater(14);

                alertServices.showBottomLeftToast('Drag marker to point exact location.', 10000);

                vm.branch.address = result.formatted_address;
                vm.branch.latlng = result.geometry.location.toJSON();
            }

            $rootScope.$on('search-address-return-result', function (e, params) {
                vm.branch.address = params.result.formatted_address;
                setPlotMarkerLocation(params.result.geometry.location);
            });

            $scope.$on('$destroy', function () {
                cleanUp();
            });
        }

        function cleanUp () {
            if (dragendListener) {
                gmapServices.removeListener(dragendListener);
            }

            if (plotMarker && plotMarker.getMap()) {
                plotMarker.setMap(null);
                plotMarker = null;
            }
        }

        function createPlotMarker (latlng) {
            var marker = gmapServices.initMarker(latlng, markerUrl, {draggable: true});

            dragendListener = gmapServices.addListener(marker, 'dragend', function(e) {
                // reverse geocode latlng
                gmapServices.reverseGeocode(e.latLng)
                    .then(function(result){
                        if (result.length) vm.branch.address = result[0].formatted_address;
                    });
            });

            return marker;
        }

        function setPlotMarkerLocation(latlng) {
            gmapServices.panTo(latlng);

            if (plotMarker && plotMarker.getMap()) {
                plotMarker.setOptions({
                    visible: true,
                    animation: google.maps.Animation.DROP,
                    position: latlng
                });
            }
        }

        function getFormData () {
            var date = formHelperService.getDateFormatted(vm.branch.operation_started_date);

            var formData = angular.copy(vm.branch);
            formData.operation_started_date = date;
            formData.latlng = plotMarker.getPosition().toJSON();

            return formData;
        }

        function save () {
            if (!vm.form.$valid) {
                formHelperService.showFormErrors(vm.form.$error);
                return;
            }

            //console.log('branch: ', vm.branch);

            var formData = getFormData();

            // process send to backend
            //console.log('formData: ', formData);

            branchService.saveBranch(formData)
                .then(function(response){
                    //console.log('save branch: ',response);
                    alertServices.showSuccess('New Branch saved.');
                    modalServices.hideResolveModal(response);
                },function(error){
                    console.log('save branch error: ', error);
                    // show errors
                    alertServices.showError(formHelperService.getFormattedErrors(error.data));
                })
                .finally(function(){
                    // hide spinner
                });
        }

        function setLocation () {
            $('#index-container .md-dialog-container').hide();
            plotMarker.setVisible(false);
            gmapServices.setMapCursorCrosshair();

            var mapClickListener = gmapServices.addMapListener('click', function(e){
                $('#index-container .md-dialog-container').show();
                gmapServices.setMapCursorDefault();
                gmapServices.removeListener(mapClickListener);

                $timeout(function(){
                    setPlotMarkerLocation(e.latLng);
                }, 500);
            });
        }

        function close () {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('compareBranchesTableController', ['$rootScope', '$scope', 'SEMESTERS', 'branchService', compareBranchesTableController]);

    function compareBranchesTableController ($rootScope, $scope, SEMESTERS, branchService) {
        var vm = this;

        vm.branchCompareList = [];
        $rootScope.showBranchCompareTable = false;
        vm.currentIndex = 0;

        vm.semesters = SEMESTERS;

        vm.filter = {
            semester: null
        };

        vm.removeBranch = removeBranch;
        vm.hoverIn = hoverIn;
        vm.hoverOut = hoverOut;
        vm.close = close;
        vm.semesterChanged = semesterChanged;

        initialize();

        function initialize() {

            $rootScope.$on('clear-compare-branches', function (e) {
                clearCompareBranch();
            });

            $scope.$watchCollection(function () {
                return vm.branchCompareList;
            }, function (newCollection) {
                //console.log('branchCompareList: ', newCollection);

                if (newCollection.length) {
                    $rootScope.showBranchCompareTable = true;
                    $('#show-compare-branches-btn').show();

                    if (vm.filter.semester) semesterChanged(vm.filter.semester);

                    return;
                }

                $rootScope.showBranchCompareTable = false;
                $('#show-compare-branches-btn').hide();
                branchService.resetMarkersColor();
            });

            $rootScope.$on('new-compare-branch', function (e, branch) {
                if (_.findWhere(vm.branchCompareList, {id: branch.id})) return;

                if (vm.branchCompareList.length == 0) branchService.unHighlightMarkers();

                vm.branchCompareList.push(transform(branch));

                vm.branchCompareList = _.sortBy(vm.branchCompareList, function(item){
                    var products = getProductsByItem(item);
                    return products.length;
                }).reverse();

                //console.log('new-compare-branch branchCompareList= ',vm.branchCompareList);

                compileList();
                highlightComparedBranches();
            });

            $rootScope.$watch('showBranchCompareTable', function (newValue, oldValue) {
                if (newValue === oldValue) return;

                if (newValue) {
                    branchService.unHighlightMarkers();
                    highlightComparedBranches();
                }
                else branchService.resetMarkersColor();
            });

            $(document).on('mouseover', '#compare-branch-table-container table.md-table tr:nth-child(2) td', function () {
                var index = $(this).index();
                $("#compare-branch-table-container table.md-table tr").find("td:nth-child(" + (index + 1) + ")").addClass("current-col");
            });

            $(document).on('mouseout', '#compare-branch-table-container table.md-table tr:nth-child(2) td', function () {
                var index = $(this).index();
                $("#compare-branch-table-container table.md-table tr").find("td:nth-child(" + (index + 1) + ")").removeClass("current-col");
            });
        }

        function highlightComparedBranches () {
            var ids = _.pluck(vm.branchCompareList, 'id');
            branchService.highlightMarkers(ids);
        }

        function transform (obj) {
            var result = {};

            result['id'] = obj.id;
            result['name'] = {name: obj.name, isbranch: true};

            obj.products.forEach(function(prod){
               result[prod.product.name] = {
                   name: prod.product.name,
                   material_code: prod.product.material_code
               };
            });

            return result;
        }

        function getProductsByItem (item) {
            var products = [];
            for (var key in item) if (key != 'id' || key != 'name') products.push(key);
            return products;
        }

        function getProductsInCollection (collection) {
            var products = [];
            collection.forEach(function(item){
                for (var key in item) if (key != 'id' || key != 'name') products.push(key);
            });
            return products;
        }

        function indexByAttribute(collection) {
            //console.log('collection: ',collection);

            var products = getProductsInCollection(collection);

            var result = {},
                resObj = {};

            for (var i = 0; i < collection.length; i++) {
                for (var key in collection[i]) {
                    resObj = {};

                    var item = collection[i].hasOwnProperty(key) ? collection[i][key] : {name: null};

                    if (!result.hasOwnProperty(key)) result[key] = [];

                    if (key === 'id' || key === 'name') {
                        resObj = item.hasOwnProperty('name')
                            ? {'value': item.name}
                            : {'value': item};
                        result[key].push(resObj);
                    } else {
                        console.log('item: ',item);
                        if (products.indexOf(key) > -1) {
                            resObj = item.hasOwnProperty('name')
                                ? {'value': item.name + ' - ' + item.material_code}
                                : {'value': item};

                            if (item.hasOwnProperty('sellout')) resObj['sellout'] = item.sellout;
                            else resObj['sellout'] = 0;

                        } else {
                            resObj = {'value': null};
                        }
                        result[key].push(resObj);
                    }
                }
            }

            //console.log('result: ',result);
            return result;
        }

        function compileList () {
            //console.log('compile list: ', vm.branchCompareList);
            vm.list = indexByAttribute(vm.branchCompareList);
        }

        function removeBranch(branchId) {
            var index = _.findIndex(vm.branchCompareList, {id: branchId});

            if (index > -1) {
                branchService.unHighlightMarker(branchId);

                vm.branchCompareList.splice(index, 1);

                compileList();

                if($scope.$$phase) return;
            }
        }

        function clearCompareBranch () {
            vm.branchCompareList = [];

            if ($scope.$$phase) return;

            $scope.$apply(function () {
                vm.list = [];
            });

            close();
        }

        function hoverIn (branchId) {
            branchService.animateMarker(branchId);
        }

        function hoverOut (branchId) {
            branchService.clearAnimationMarker(branchId);
        }

        function close () {
            $rootScope.showBranchCompareTable = false;
        }

        function assignSellout(selloutData) {
            //console.log('assign sellout : ',selloutData);

            var foundSellout;

            vm.branchCompareList.forEach(function(branch, index){
                for (var key in branch) {
                    if (key == 'id' || key == 'name') continue;

                    foundSellout = _.find(selloutData, function(sellout){
                        return  sellout.branchid === branch.id
                            && key.toLowerCase() === sellout.product.name.toLowerCase();
                    });

                    if (foundSellout) branch[key]['sellout'] = foundSellout.grossup_amount;

                    //var foundIndex = _.find(selloutData, function (sellout) {
                    //    return sellout.branchid == branch.id
                    //        && key.toLowerCase() == sellout.product.name.toLowerCase();
                    //});
                    //if (foundIndex > -1) vm.branchCompareList[index][key]['sellout'] = selloutData[foundIndex].grossup_amount;

                }
            });

            console.log('after assigning sellout: ',vm.branchCompareList);

            compileList();
        }

        function resetSellouts () {
            vm.branchCompareList.forEach(function (branch) {
                for (var key in branch) {
                    if (key == 'id' || key == 'name') continue;
                    if (branch[key].hasOwnProperty('sellout')) delete branch[key]['sellout'];
                }
            });
            //console.log('after assigning sellout: ', vm.branchCompareList);
            compileList();
        }

        function semesterChanged (semester) {
            //console.log('semesterChanged: ',semester);

            resetSellouts();

            var branchIdsArray = _.pluck(vm.branchCompareList, 'id');

            branchService.getSellouts(semester, branchIdsArray)
                .then(function(sellouts){
                    console.log('sellouts: ', sellouts);
                    assignSellout(sellouts);
                });

        }

    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.home', [
            'vAccordion'
        ]);

}());

(function(){
'use strict';

angular.module('demoApp.home')
    .factory('userTerritoriesService', ['$q', 'userSessionService', 'Territory', 'gmapServices', userTerritoriesService]);

    function userTerritoriesService ($q, userSessionService, Territory, gmapServices) {
        var service = {};

        var abort;

        var polygonColor = '#3f51b5';

        service.getTerritories = getTerritories;
        service.getTerritoryBranches = getTerritoryBranches;
        service.showTerritoryPolygon = showTerritoryPolygon;

        function getTerritories () {
            var dfd = $q.defer();

            var currentUser = userSessionService.getUserInfo(true);

            currentUser.getList('territories')
                .then(function(response){
                    dfd.resolve(response.plain());
                }, function(error){
                    console.log('get user territories error: ', error);
                    dfd.reject(error);
                })

            return dfd.promise;
        }

        function getTerritoryBranches (territoryId) {
           var dfd = $q.defer();

            if (abort) abort.resolve();

            abort = $q.defer();

            Territory.cast(territoryId)
               .withHttpConfig({timeout: abort})
               .getList('branches')
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        console.log('error: ', error);
                        dfd.reject(error);
                    });

            return dfd.promise;
        }

        function showTerritoryPolygon(latlngArray) {
            return gmapServices.createPolygon(latlngArray, polygonColor);
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('userSessionService', ['User', 'localStorageService', '$q', userSessionService]);

    function userSessionService (User, localStorageService, $q) {
        var service = {};

        // user details
        var USER = 'USER',
            FRAUD_DATA = 'FRAUD_DATA'

        service.userLogin = userLogin;
        service.userLogout = userLogout;
        service.getUserInfo = getUserInfo;
        service.saveFraudData = saveFraudData;
        service.getFraudData = getFraudData;


        function saveFraudData (data) {
            if (!localStorageService.isSupported) return;

            localStorageService.set(FRAUD_DATA, data);
        }

        function getFraudData () {
            if (!localStorageService.isSupported) return;

            return localStorageService.get(FRAUD_DATA);
        }


        function userLogin () {
            if (!localStorageService.isSupported) return;

            var dfd = $q.defer();
            var currentUser = getUserInfo();

            if (currentUser) {
                dfd.resolve(currentUser);
            } else {
                User.customGET('current_user')
                    .then(function (response) {
                        localStorageService.set(USER, response.plain());
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function userLogout () {
            if (!localStorageService.isSupported) return;

            // clear all data on local storage on logout
            localStorageService.clearAll();
        }

        function getUserInfo (isRestangular) {
            if (!localStorageService.isSupported) return;

            var userObj = localStorageService.get(USER);

            return isRestangular && userObj ?
                            User.cast(userObj.id)
                            : userObj;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .factory('User', ['Restangular', User]);

    function User(Restangular) {
        var myModel = Restangular.all('users');

        var resource = {
            cast: function (userId) {
                return Restangular.restangularizeElement(null, {id: userId}, 'users');
            }
        };

        Restangular.extendModel('users', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('indexController', ['gmapServices', '$rootScope', '$mdSidenav', 'modalServices', '$injector', indexController]);

    function indexController (gmapServices, $rootScope, $mdSidenav, modalServices, $injector) {
        var vm = this;

        vm.lastSideNavOpenId = '';

        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        initialize();

        function initialize() {
            gmapServices.createMap('map-canvas');

            $rootScope.$on('search-address-return-result', function (e, params) {
               if ($rootScope.hasOpenedModal) return;

               modalServices.showMapPlotOptions(e)
                   .then(function(selectedOption){
                       $injector.get('modalServices')[selectedOption.action](e, params)
                           .finally(function(){
                               $rootScope.$broadcast('clear-search-address-bar');
                           });
                   });
            });
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }
                $mdSidenav(navID).toggle();
                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('gmapController', [gmapController]);

    function gmapController() {

        //function showSolarDetailInfowindow (_solar) {
        //    if(!(_solar && _solar.id)) return;
        //
        //    solarGmapServices.hideSolarMarkers();
        //
        //    var defered = modalServices.showUpdateSolar(_solar, vm, event);
        //    defered.then(function (response) {
        //        console.log('modalServices.showUpdateSolar response:');
        //        console.log(response);
        //
        //            if (!response) return;
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //            if($rootScope.selectedSolar && response) {
        //                $rootScope.selectedSolar.coordinates = response.coordinates;
        //            }
        //        }, function (errorResponse) {
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //
        //            console.log('show update solar detail failed');
        //            console.log(errorResponse);
        //        });
        //}
        //
        //
        //function showMarkers () {
        //    solarGmapServices.showSolarMarkers();
        //    solarGmapServices.resetZoom();
        //}

        //function hideMarkers () {
        //    console.log('called from event : modal-opened');
        //    console.log('gmapcontroller hide markers');
        //    solarGmapServices.hideSolarMarkers();
        //    // Hide Solar List Table
        //    $rootScope.showSolarList = false;
        //}
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('branchService', ['MARKER_BASE_URL', '$q', 'Branch', 'gmapServices', '$rootScope', branchService]);

    function branchService (MARKER_BASE_URL, $q, Branch, gmapServices, $rootScope) {
        var service = {};

        var branchMarkers = [],
            branchInfowindow,
            heatmap;

        var gradient = [
            'rgba(0, 255, 255, 0)',
            'rgba(0, 255, 255, 1)',
            'rgba(0, 191, 255, 1)',
            'rgba(0, 127, 255, 1)',
            'rgba(0, 63, 255, 1)',
            'rgba(0, 0, 255, 1)',
            'rgba(0, 0, 223, 1)',
            'rgba(0, 0, 191, 1)',
            'rgba(0, 0, 159, 1)',
            'rgba(0, 0, 127, 1)',
            'rgba(63, 0, 91, 1)',
            'rgba(127, 0, 63, 1)',
            'rgba(191, 0, 31, 1)',
            'rgba(255, 0, 0, 1)'
        ];

        var salesGradient = [
            'rgba(0, 255, 255, 0)',
            'rgba(0, 255, 255, 1)',
            'rgba(0, 191, 255, 1)',
            'rgba(0, 127, 255, 1)',
            'rgba(0, 63, 255, 1)',
            'rgba(0, 0, 255, 1)',
            'rgba(0, 0, 223, 1)',
            'rgba(0, 0, 191, 1)',
            'rgba(0, 0, 159, 1)',
            'rgba(0, 0, 127, 1)',
            'rgba(63, 0, 91, 1)',
            'rgba(127, 0, 63, 1)',
            'rgba(191, 0, 31, 1)',
            'rgba(255, 0, 0, 1)'
        ];

        var branchIcons = {
            'mdc': 'branch-red.png',
            'lka': 'branch-green.png',
            'gt': 'branch-blue.png'
        };

        var iconBaseUrl = MARKER_BASE_URL;
        var unhighlightIcon = 'branch-default.png';

        var previouslyHighlightedMarkerIds = [];

        service.saveBranch = saveBranch;
        service.loadMarkers = loadMarkers;
        service.showMarkers = showMarkers;
        service.hideMarkers = hideMarkers;
        service.toggleMarkers = toggle;
        service.dismissInfowindow = dismissInfowindow;
        service.getBranchById = getBranchById;
        service.getRestangularObj = getRestangularObj;
        service.highlightMarkers = highlightMarkers;
        service.resetMarkersColor = resetMarkersColor;
        service.unHighlightMarkers = unHighlightMarkers;
        service.unHighlightMarker = unHighlightMarker;
        service.animateMarker = animateMarker;
        service.clearAnimationMarker = clearAnimationMarker;
        service.deleteBranch = deleteBranch;
        service.newBranch = newBranch;
        service.triggerClickBranch = triggerClickBranch;
        service.loadProducts = loadProducts;
        service.highlightMarkersOnSaturation = highlightMarkersOnSaturation;
        service.uploadBranchData = uploadBranchData;
        service.uploadBranchSellOutData = uploadBranchSellOutData;
        service.getSellouts = getSellouts;
        service.getSelloutsByProduct = getSelloutsByProduct;
        service.displaySellouts = displaySellouts;
        service.showHeatmap = showHeatmap;
        service.hideHeatmap = hideHeatmap;


        function loadProducts (list) {
            var dfd = $q.defer();

            var branchIds = _.pluck(list, 'id');

            Branch.customPOST({branch_ids: branchIds}, 'products')
                .then(function(response){
                    dfd.resolve(response.plain());
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function triggerClickBranch (branchId) {
            var marker = getBranchById(branchId);

            if (!marker) return;

            gmapServices.trigger(marker, 'click');
            //gmapServices.trigger(marker, 'spider_click');
        }

        // add to markers
        function newBranch (item, isProductSaturation) {
            var icon = getBranchIconByType(item.type, isProductSaturation);
            var marker = gmapServices.initMarker(item.latlng, icon, {zIndex: 1});

            if (!item.latlng || _.isEmpty(item.latlng)) return;

            marker.originalPosition = new google.maps.LatLng(item.latlng);

            marker.content = '<div>';
            marker.content += '<h3 class="no-margin padding-left-5"><b>' + item.name + '</b></h3>';
            marker.content += '<h4 class="no-margin text-muted padding-left-5">' + item.type + '</h4>';

            if (!isProductSaturation) {
                marker.content += '<button id="compare-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-primary">Compare</button>';
                marker.content += '<button id="get-distance-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-accent">Get Distance</button>';
            }

            //if ($rootScope.currentUser.role === 'ADMIN') {
                //if (isProductSaturation) {
                //    marker.content += '<button id="add-product-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-accent">Add Product</button>';
                //}

                //if (!isProductSaturation) {
                    //marker.content += '<button id="edit-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-warn">Edit</button>';
                    //marker.content += '<button id="delete-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-default">Delete</button>';
                //}
            //}
            marker.content += '</div>';

            marker.iconUrl = icon;
            marker.branch = angular.copy(item);
            marker.id = item.id;
            marker.touched = false;

            gmapServices.addListener(marker, 'click', function () {
                branchInfowindow.open(gmapServices.map, this);
                branchInfowindow.setContent(this.content);
            });

            gmapServices.spiderifier.addMarker(marker, function () {
                branchInfowindow.open(gmapServices.map, this);
                branchInfowindow.setContent(this.content);
            });

            branchMarkers.push(marker);

            return marker;
        }

        function saveBranch (data, id) {
            var dfd = $q.defer();

            if (id) { // update
                var restObj = Branch.cast(id);
                restObj.customPUT(data)
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            } else { // insert
                Branch.post(data)
                    .then(function(response){
                        var resp = response.plain();
                        console.log('post branch ', resp);
                        newBranch(resp.branch);
                        dfd.resolve(resp);
                    }, function(error){
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function getBranchIconByType (type, isProductSaturation) {
            if (!type || isProductSaturation) return iconBaseUrl + unhighlightIcon;

            return iconBaseUrl + branchIcons[type.toLowerCase()];
        }

        function loadMarkers (list, isProductSaturation, infowindow) {
            hideMarkers();

            branchMarkers = [];

            if (infowindow) branchInfowindow = infowindow;
            else if (!infowindow && !branchInfowindow) branchInfowindow = gmapServices.createInfoWindow('');

            // for spider
            gmapServices.initializeSpiderify();

            list.forEach(function (item) {
               newBranch(item, isProductSaturation);
            });

            $rootScope.$broadcast('compile-map-legend', {type: 'branches', data: getMapLegendData(list)});
        }

        function getMapLegendData (list) {
            return _.pluck(_.uniq(list, function(item){
                return item.type;
            }), 'type').map(function(type){
                return {
                    name: type,
                    iconUrl: getBranchIconByType(type)
                };
            });
        }

        function showMarkers() {
            branchMarkers.forEach(function (marker) {
                if (marker && !marker.getVisible()) marker.setVisible(true);
            });
        }

        function hideMarkers () {
            branchMarkers.forEach(function (marker) {
                if (marker && marker.getVisible()) marker.setVisible(false);
            });

            if (branchInfowindow) branchInfowindow.close();
        }

        function toggle () {
            if (branchMarkers.length) {
                if (branchMarkers[0].getVisible()) {
                    hideMarkers();
                } else {
                    showMarkers();
                }
            }
        }

        function dismissInfowindow () {
            if (branchInfowindow) branchInfowindow.close();
        }

        function getBranchById (branchId) {
            return _.findWhere(branchMarkers, {id: branchId});
        }

        function getRestangularObj(branchId) {
            return Branch.cast(branchId);
        }

        function highlightMarkersOnSaturation(branchIds, showAsHeatmap) {
            var icon,
                isFound,
                foundCtr = 0,
                markerIdsToUnhighlight = [];

            if (!showAsHeatmap) {
                if (heatmap) heatmap.setMap(null);
                showMarkers();
            }

            if (previouslyHighlightedMarkerIds.length) {
                markerIdsToUnhighlight = _.difference(previouslyHighlightedMarkerIds, branchIds);
                _.filter(branchMarkers, function(itm){
                   return markerIdsToUnhighlight.indexOf(itm.id) > -1;
                }).forEach(function(itemMarker){
                    itemMarker.setZIndex(1);
                    itemMarker.setIcon(getBranchIconByType());
                });
            }

            if (showAsHeatmap) {
                if (!heatmap) heatmap = gmapServices.createHeatmap([], gradient);
                else if (heatmap && !heatmap.getMap()) heatmap.setMap(gmapServices.map);

                var latlngData = [];

                hideMarkers();

                _.filter(branchMarkers, function (itm) {
                    return branchIds.indexOf(itm.id) > -1;
                }).forEach(function (item) {
                    latlngData.push(item.getPosition());
                    item.touched = true;
                    foundCtr++;
                });
                heatmap.setData(latlngData);
                previouslyHighlightedMarkerIds = angular.copy(branchIds);
            } else {
                _.filter(branchMarkers, function (itm) {
                    return branchIds.indexOf(itm.id) > -1;
                }).forEach(function (item) {
                    item.setZIndex(2);
                    item.setIcon(getBranchIconByType(item.branch.type));
                    item.touched = true;
                    foundCtr++;
                });
                previouslyHighlightedMarkerIds = angular.copy(branchIds);
            }


            return foundCtr;
        }

        function highlightMarkers (branchIds, isProductSat) {
            var icon,
                isFound,
                foundCtr = 0;


            if (isProductSat) {
                var toHighlightMarkers = _.filter(branchMarkers, function (itm) {
                    return branchIds.indexOf(itm.id) > -1;
                });

                toHighlightMarkers.forEach(function (item) {
                    item.setZIndex(2);
                    item.setIcon(getBranchIconByType(item.branch.type));
                    item.touched = true;
                    foundCtr++;
                });
                return;
            }

            branchMarkers.forEach(function(item){
                isFound = branchIds.indexOf(item.id) > -1;

                if (isFound) {
                    item.setZIndex(2);
                    item.setIcon(getBranchIconByType(item.branch.type));
                    item.touched = true;
                    foundCtr++;
                }

                //if (isFound) {
                //    item.setZIndex(2);
                //    foundCtr++;
                //}
                //icon = isFound
                //       ? getBranchIconByType(item.branch.type)
                //       : getBranchIconByType();
                //
                //item.setIcon(icon);
            });

            return foundCtr;
        }

        function resetMarkersColor (isProductSaturation) {
            var icon;

            if (isProductSaturation) {
                var touchedMarkers = _.where(branchMarkers, {touched: true});

                if (touchedMarkers.length) {
                    touchedMarkers.forEach(function (item) {
                        icon = getBranchIconByType(item.branch.type, isProductSaturation);
                        item.setIcon(getBranchIconByType(item.branch.type, isProductSaturation));
                        item.setZIndex(1);
                    });
                }
                return;
            }


            branchMarkers.forEach(function (item) {
                icon = getBranchIconByType(item.branch.type, isProductSaturation);

                if (item.getIcon() == icon) return;

                item.setIcon(icon);
                //item.setZIndex(1);
            });
        }

        function unHighlightMarkers() {
            var defaultIcon = getBranchIconByType();
            branchMarkers.forEach(function (item) {
                if (item.getIcon() != defaultIcon && !item.touched) {
                    item.setIcon(defaultIcon);
                    item.setAnimation(null);
                    item.setZIndex(1);
                }
            });

        }

        function unHighlightMarker (branchId) {
            var found = getBranchById(branchId);

            if (!found) return;

            found.touched = false;
            found.setIcon(getBranchIconByType());
            found.setZIndex(1);
            found.setAnimation(null);
        }

        function animateMarker (branchId) {
            var found = getBranchById(branchId);

            if (!found) return;

            //gmapServices.panToMarker(found);
            found.setAnimation(google.maps.Animation.BOUNCE);
        }

        function clearAnimationMarker (branchId) {
            var found = getBranchById(branchId);

            if (!found) return;

            found.setAnimation(null);
        }

        function deleteBranch(branchId) {
            var dfd = $q.defer();

            var restObj = getRestangularObj(branchId);

            restObj.remove()
                .then(function (response) {

                    dismissInfowindow();

                    var index = _.findIndex(branchMarkers, {id: branchId});

                    if (index > -1) {
                        if (branchMarkers[index] && branchMarkers[index].getMap()) {
                            branchMarkers[index].setVisible(false);
                            gmapServices.clearInstanceListeners(branchMarkers[index]);
                            branchMarkers[index].setMap(null);
                            branchMarkers[index] = null;
                            console.log('clearing branch marker');
                        }
                        branchMarkers.splice(index, 1);
                    }

                    dfd.resolve(response);
                }, function (error) {
                    console.log('error: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function uploadBranchData(file) {
            var dfd = $q.defer();

            if (!file) {
                dfd.reject();
            } else {
                file.upload = Branch.uploadData(file);

                file.upload.then(function (response) {
                    file.result = response.data;
                    dfd.resolve(response.data);
                }, function (error) {
                    dfd.reject(error);
                }, function (evt) {
                    file.progress = Math.min(100, parseInt(100.0 *
                        evt.loaded / evt.total));

                });
            }

            return dfd.promise;
        }

        function uploadBranchSellOutData(file) {
            var dfd = $q.defer();

            if (!file) {
                dfd.reject();
            } else {
                file.upload = Branch.uploadSellOutData(file);

                file.upload.then(function (response) {
                    file.result = response.data;
                    dfd.resolve(response.data);
                }, function (error) {
                    dfd.reject(error);
                }, function (evt) {
                    file.progress = Math.min(100, parseInt(100.0 *
                        evt.loaded / evt.total));

                });
            }

            return dfd.promise;
        }

        function getSellouts(semester, branchIdsArray) {
            var dfd = $q.defer();

            Branch.getSellouts(semester, branchIdsArray)
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getSelloutsByProduct(semester, product) {
            var dfd = $q.defer();

            Branch.getSelloutsByProduct(semester, product)
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getHeatmapWeight (grossupAmount) {
            if (grossupAmount == 0) {
                return 0.5;
            } else if (grossupAmount > 0 && grossupAmount <= 300) {
                return 3;
            } else if (grossupAmount > 300 && grossupAmount <= 500) {
                return 5;
            } else if (grossupAmount > 500 && grossupAmount <= 1000) {
                return 10;
            } else if (grossupAmount > 1000) {
                return 20;
            }
        }

        function displaySellouts (selloutData) {
            console.log('displaySellouts: ',selloutData);

            var heatMapData = [];

            selloutData.forEach(function(item, idx){
               if (item.branch && item.branch.latlng) {
                   heatMapData.push({
                       location: new google.maps.LatLng(item.branch.latlng),
                       weight: getHeatmapWeight(item.grossup_amount)
                   });
               }
            });

            if (!heatmap) heatmap = gmapServices.createHeatmap(heatMapData, salesGradient);
            else {
                showHeatmap();
                heatmap.setOptions({
                    data: heatMapData,
                    gradient: salesGradient
                });
            }
            //console.log('heatmap data: ',heatMapData);
        }

        function showHeatmap() {
            if (heatmap && !heatmap.getMap()) heatmap.setMap(gmapServices.map);
        }

        function hideHeatmap() {
            if (heatmap && heatmap.getMap()) heatmap.setMap(null);
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('Branch', ['Restangular', 'Upload', Branch]);
    
    function Branch (Restangular, Upload) {
        var myModel = Restangular.all('branches');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'branches');
            },

            uploadData: function (fileParam) {
                var uploadUrl = myModel.getRestangularUrl() + '/' + 'upload';
                return Upload.upload({
                    url: uploadUrl,
                    method: 'POST',
                    data: {file: fileParam}
                });
            },

            uploadSellOutData: function (fileParam) {
                var uploadUrl = myModel.getRestangularUrl() + '/sellouts/' + 'upload';
                return Upload.upload({
                    url: uploadUrl,
                    method: 'POST',
                    data: {file: fileParam}
                });
            },

            getSellouts: function (semester, branchIdsArray) {
                var param = {'semester': semester, 'branch_ids': branchIdsArray.join(',')};

                return myModel
                    .all('sellouts')
                    .getList(param);
            },

            getSelloutsByProduct: function (date, product) {
                var param = {'date': date, 'product': product};

                return myModel
                    .all('sellouts')
                    .getList(param);
            }
        };

        Restangular.extendModel('branches', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
//google.load('visualization', '1', {
//    packages: ['table']
//});

(function () {
    'use strict';

    angular
        .module('demoApp', [
            'restangular',
            'LocalStorageModule',
            'ngMaterial',
            'ngAnimate',
            'oitozero.ngSweetAlert',
            'ngFileUpload',
            'md.data.table',
            'angularMoment',
            'smDateTimeRangePicker',
            'ngMaterialDateRangePicker',
            'demoApp.home',
            'demoApp.admin',
            'demoApp.sales',
            'demoApp.fraud',
            'demoApp.productSaturation'
        ])

        .constant('APP_NAME', 'UNILAB')
        .constant('BASE_URL', window.location.origin)
        .constant('MARKER_BASE_URL', '/images/markers/')

        .constant('DEMO_MODE_MESSAGE', 'Functionality disabled for POC')

        .constant('SEMESTERS', [
            {
                display: 'Sem 1 - 2016',
                value: '2016-01-01'
            },
            {
                display: 'Sem 2 - 2016',
                value: '2016-07-01'
            }
        ])


        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }])

        .config(["localStorageServiceProvider", function (localStorageServiceProvider) {
            localStorageServiceProvider
                .setPrefix('UNILAB')
                .setStorageType('sessionStorage')
                .setNotify(true, true)
            ;
        }])

        .run(["userSessionService", "$rootScope", function(userSessionService, $rootScope){
            userSessionService.userLogin()
                .then(function (user) {
                    $rootScope.currentUser = angular.copy(user);
                });
        }])

        .filter('underscoreless', function () {
            return function (input) {
                return input.replace(/_/g, ' ');
            };
        })
        .config(["$mdThemingProvider", function ($mdThemingProvider) {
        //    $mdThemingProvider.theme('default')
        //        .primaryPalette('red')
        //        .accentPalette('pink');
            $mdThemingProvider.theme('docs-dark', 'default')
                .primaryPalette('yellow')
                .dark();
        }])
    ;

}());

String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

Date.prototype.addDays = function (days) {
    var dat = new Date(this.valueOf())
    dat.setDate(dat.getDate() + days);
    return dat;
};

window.paceOptions = {
    ajax: {
        trackMethods: ["GET", "POST", "DELETE"],
        trackWebSockets: false
    },
    document: true, // disabled
    eventLag: true,
    restartOnPushState: true,
    restartOnRequestAfter: true
};
(function(){
'use strict';

angular.module('demoApp')
    .factory('userResourcesService', ['$q', 'userSessionService', 'User', userResourcesService]);

    function userResourcesService ($q, userSessionService, User) {
        var service = {};

        var transactionTypes = {
            'CLIENT VISIT': 'store',
            'GAS': 'local_gas_station',
            'FLIGHT': 'flight_takeoff',
            'COVERAGE': 'flag',
            '1SS': 'local_atm',
            'C3S': 'crdit_card',
            'IIDACS': 'finance',
            'FLEET': 'local_taxi'
        };

        service.getUserTransactions = getUserTransactions;
        service.getEmployees = getEmployees;
        service.getUserTerritories = getUserTerritories;

        function getEmployees () {
            var dfd = $q.defer();

            User.getList({roleid: 2})
                .then(function(response){
                    dfd.resolve(response.plain().map(function(emp){
                        emp.name = emp.lastname.capitalize() + ', ' + emp.firstname.capitalize();
                        return emp;
                    }));
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getUserTransactions () {
            var dfd = $q.defer();

            var user = userSessionService.getUserInfo();

            if (user) {
                User.cast(user.id)
                    .getList('salestransactions')
                        .then(function(response){
                            dfd.resolve(response.plain().map(function(item){
                                item.icon = transactionTypes[item.type.toUpperCase()];
                                return item;
                            }));
                        }, function(error){
                            dfd.reject(error);
                        });
            } else {
                dfd.reject();
            }

            return dfd.promise;
        }

        function getUserTerritories (userId) {
            var dfd = $q.defer();

            User.cast(userId).getList('territories')
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Sellout', ['Restangular', Sellout]);

    function Sellout(Restangular) {
        var myModel = Restangular.all('sellouts');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'sellouts');
            }
        };

        Restangular.extendModel('sellouts', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('searchAddressBarController', ['$rootScope', 'gmapServices', 'alertServices', 'DEMO_MODE_MESSAGE', searchAddressBarController]);

    function searchAddressBarController($rootScope, gmapServices, alertServices, DEMO_MODE_MESSAGE) {
        var vm = this;

        var autocomplete = null;

        vm.getGPSLocation = getGPSLocation;

        initialize();

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input', {
                componentRestrictions: {country: 'ph'}
            });

            autocomplete.addListener('place_changed', placeChangeCallback);

            $rootScope.$on('clear-search-address-bar', function(e){
                vm.query = '';
            });
        }

        function placeChangeCallback() {
            var place = autocomplete.getPlace();

            if (!place.geometry) {
                alertServices.showInfo("Address not found.");
                return;
            }

            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }

            $rootScope.$broadcast('search-address-return-result', {result: place});
        }

        function getGPSLocation () {
            alertServices.showInfo(DEMO_MODE_MESSAGE);
            //locationService.getCurrentLocation()
            //    .then(function(latlng){
            //        gmapServices.reverseGeocode(latlng)
            //            .then(function (result) {
            //                if (result.length) $rootScope.$broadcast('search-address-return-result', {result: result[0]});
            //            });
            //    }, function (error){
            //        alertServices.showError(error.message);
            //    });
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('placesService', ['Place', '$rootScope', '$q', 'gmapServices', placesService]);

    function placesService (Place, $rootScope, $q, gmapServices) {
        var service = {};

        var placeTypesDelimiter = '|';

        var iconByplaceTypes = {
            'hospital': {
                icon: 'hospital',
                color: '#E91E63'
            },
            'pharmacy': {
                icon: 'health',
                color: '#9b59b6'
            },
            'shopping_mall': {
                icon: 'department-store',
                color: '#9b59b6'
            },
            'school': {
                icon: 'school',
                color: '#7f8c8d'
            },
            'convenience_store': {
                icon: 'convenience-store',
                color: '#f39c12'
            }
        };

        service.defaultPlaceTypes = [
            //'hospital',
            //'pharmacy'
        ];

        var poiMarkers = [],
            poiInfowindow;

        var abort1,
            abort2;

        service.loadPOIs = loadPOIs; // load within territory
        service.loadPOIsWithinBoundary = loadPOIsWithinBoundary;
        service.showPOIs = showPOIs;
        service.showPOIByType = showPOIByType;
        service.showVisiblePOIs = showVisiblePOIs;
        service.hidePOIs = hidePOIs;
        service.getPlaceTypes = getPlaceTypes;
        service.dismissInfowindow = dismissInfowindow;

        function loadPOIs (territoryId, typesArray) {
            var dfd = $q.defer();

            if (abort1) abort1.resolve();

            abort1 = $q.defer();

            Place.withHttpConfig({timeout: abort1.promise})
                .get('', {types: typesArray.join(placeTypesDelimiter), territoryid: territoryId})
                .then(function(response){
                    dfd.resolve(response.data);
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function loadPOIsWithinBoundary(boundaryId, typesArray) {
            var dfd = $q.defer();

            if (abort2) abort2.resolve();

            abort2 = $q.defer();

            Place.withHttpConfig({timeout: abort2.promise})
                .get('', {types: typesArray.join(placeTypesDelimiter), boundaryid: boundaryId})
                .then(function (response) {
                    console.log('places: ',response);
                    dfd.resolve(response.data);
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function showPOIs(list, infowindow) {
            var marker,
                placeType;

            if (infowindow) poiInfowindow = infowindow;
            else if (!infowindow && !poiInfowindow) poiInfowindow = gmapServices.createInfoWindow('');

            hidePOIs();

            poiMarkers = [];

            for (var poiType in list) {
                list[poiType].forEach(function (item) {
                    placeType = getPlaceIcon(item.type);
                    marker = gmapServices.createMapIconLabel(item.geometry.location, placeType.icon || 'compass', placeType.color);
                    marker.name = item.name;
                    marker.type = item.type;
                    marker.content = '<b>' + item.name + '</b>';
                    marker.content += '<br>' + marker.type;

                    gmapServices.addListener(marker, 'click', function () {
                        poiInfowindow.open(gmapServices.map, this);
                        poiInfowindow.setContent(this.content);
                        $rootScope.$broadcast('poi-clicked', {position: this.getPosition()});
                    });

                    poiMarkers.push(marker);
                });
            }

            $rootScope.$broadcast('compile-map-legend', {type: 'places', data: getMapLegendData(list)});
        }

        function getMapLegendData(list) {
            return Object.keys(list).map(function(type){
                return {
                    name: type.capitalize(),
                    iconPlace: getPlaceIcon(type)
                };
            });
        }

        function showPOIByType(type) {
            if (type == 'all') {
                poiMarkers.forEach(function (marker) {
                    if (!marker.getMap()) marker.setMap(gmapServices.map);
                });
                return;
            }

            poiMarkers.forEach(function (marker) {
                if (type != marker.type) {
                    marker.setMap(null);
                    return;
                }

                if (!marker.getMap()) marker.setMap(gmapServices.map);
            })
        }

        function showVisiblePOIs () {
            poiMarkers.forEach(function (marker) {
                if (marker && !marker.getMap()) marker.setMap(gmapServices.map);
            });
        }

        function hidePOIs() {
            poiMarkers.forEach(function (marker) {
                if (marker && marker.getMap()) marker.setMap(null);
            });
        }

        function getPlaceTypes() {
            var result = [];
            for (var key in iconByplaceTypes) {
                result.push(key);
            }
            return result;
        }

        function getPlaceIcon(placeType) {
            return iconByplaceTypes[placeType];
        }

        function dismissInfowindow () {
            poiInfowindow.close();
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Place', ['Restangular', Place]);

    function Place(Restangular) {
        var myModel = Restangular.all('places');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'places');
            }
        };

        Restangular.extendModel('places', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            return Restangular.stripRestangular(model);
            //return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        var newTransactionModal,
            mapPlotOptionsModal,
            fraudTableModal,
            newProductModal,
            addProductToBranchModal;

        /* Service Functions */
        service.showNewBranchForm = showNewBranchForm;
        service.showNewTransactionForm = showNewTransactionForm;
        service.showMapPlotOptions = showMapPlotOptions;
        service.showFraudResult = showFraudResult;
        service.showNewProductForm  = showNewProductForm;
        service.showAddProductToBranch = showAddProductToBranch;
        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        function showNewBranchForm(ev, params) {
            var opts = {
                controller: 'newBranchController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_new_branch.html',
                parent: angular.element(document.querySelector('#index-container')),
                locals: {param: params},
                targetEvent: ev,
                hasBackdrop: false,
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(newTransactionModal, opts);
        }

        function showNewTransactionForm(ev, params) {
            var opts = {
                controller: 'newTransactionController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_new_transaction.html',
                parent: angular.element(document.querySelector('#index-container')),
                locals: {param: params},
                targetEvent: ev,
                hasBackdrop: false,
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(newTransactionModal, opts);
        }

        function showMapPlotOptions () {
            var opts = {
                controller: 'mapPlotOptionsController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_map_plot_options.html',
                parent: angular.element(document.querySelector('body')),
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(mapPlotOptionsModal, opts);
        }

        function showFraudResult (ev, data) {
            var opts = {
                controller: 'fraudReportTableController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_fraud_report_table.html',
                parent: angular.element(document.querySelector('#fraud-container')),
                locals: {data: data},
                targetEvent: ev,
                fullscreen: $mdMedia('lg')
                //onComplete: function (scope, element, options) {
                //    $('.md-scroll-mask').css('z-index', '-1');
                //}
            };

            return showModal(fraudTableModal, opts);
        }

        function showNewProductForm(ev) {
            var opts = {
                controller: 'newProductController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_new_product.html',
                parent: angular.element(document.querySelector('#product-saturation-container')),
                targetEvent: ev,
                hasBackdrop: true,
                fullscreen: customFullscreen
            };

            return showModal(newProductModal, opts);
        }

        function showAddProductToBranch (branch) {
            var opts = {
                controller: 'addProductToBranchController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_add_product_to_branch.html',
                parent: angular.element(document.querySelector('#product-saturation-container')),
                locals: {branch: branch},
                hasBackdrop: true,
                fullscreen: customFullscreen
            };

            return showModal(addProductToBranchModal, opts);
        }

        function hideResolveModal(response) {
            $rootScope.$broadcast("modal-closed");
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $rootScope.$broadcast("modal-closed");
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('mapToolsService', ['gmapServices', mapToolsService]);

    function mapToolsService (gmapServices) {
        var service = {};

        var measurePolyline,
            measureMapObjects = [],
            measureInviMarker,
            measureLabel;

        var distance,
            measureListeners = [],
            measurePaths = [];

        service.activateMeasureDistanceTool = activateMeasureDistanceTool;
        service.deactivateMeasureDistanceTool = deactivateMeasureDistanceTool;
        service.clearMeasurementLines = clearMeasurementLines;

        function redrawLine (startLatlng, endLatlng) {
            //var newPath = measurePaths.concat([endLatlng]);
            //if (measurePaths.length > 1) {
            //    measureInviMarker.setPosition(newPath[Math.abs(newPath.length / 2)]);
            //
            //} else {
                measureInviMarker.setPosition(google.maps.geometry.spherical.interpolate(startLatlng, endLatlng, 0.5));
            //}

            measurePolyline.setPath([startLatlng, endLatlng]);

            distance = google.maps.geometry.spherical.computeDistanceBetween(startLatlng, endLatlng);
            //distance = google.maps.geometry.spherical.computeLength(newPath);

            var content = distance.toFixed(2) + ' m';
            measureLabel.setContent(content);
        }

        function activateMeasureDistanceTool (startLatLng) {
            //measurePaths = [];
            //measurePaths.push(startLatLng);

            if (!measurePolyline) measurePolyline = gmapServices.createDashedPolyline([startLatLng], '#3498db');
            else {
                if (measurePolyline) measurePolyline.setMap(gmapServices.map);
                measurePolyline.setPath([startLatLng]);
            }

            if (!measureInviMarker) measureInviMarker = gmapServices.initMarker(startLatLng, null, {visible: false});
            else {
                if (measureInviMarker) measureInviMarker.setMap(gmapServices.map);
                measureInviMarker.setPosition(startLatLng);
            }

            if (!measureLabel) measureLabel = new Label({map: gmapServices.map, text: ''});
            else measureLabel.setMap(gmapServices.map);

            measureLabel.bindTo('position', measureInviMarker, 'position');

            measureListeners.push(
                gmapServices.addMapListener('mousemove', function(e){
                    redrawLine(startLatLng, e.latLng);
                })
            );

            //measureListeners.push(
            //    gmapServices.addMapListener('click', function(e){
            //        measureListeners.forEach(function (listener) {
            //            gmapServices.removeListener(listener);
            //        });
            //        measureListeners = [];
            //    })
            //);

            //measureListeners.push(
            //    gmapServices.addMapListener('dblclick', function (e) {
            //        console.log('dbl clicked!');
            //        measureListeners.forEach(function(listener){
            //            gmapServices.removeListener(listener);
            //        });
            //        measureListeners = [];
            //    })
            //);
        }

        function deactivateMeasureDistanceTool (endLatlng) {
            redrawLine(measurePolyline.getPath().getArray()[0], endLatlng);
            measureMapObjects.push(measurePolyline);
            measureMapObjects.push(measureInviMarker);
            measureMapObjects.push(measureLabel);
            measureListeners.forEach(function (listener) {
                gmapServices.removeListener(listener);
            });
            measureListeners = [];
        }

        function clearMeasurementLines () {
            measureMapObjects.forEach(function(obj, idx){
                measureMapObjects[idx].setMap(null);
                measureMapObjects[idx] = null;
            });
            measureMapObjects = [];
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mapPlotOptionsController', ['modalServices', mapPlotOptionsController]);

    function mapPlotOptionsController (modalServices) {
        var vm = this;

        vm.options = [
            {
                name: 'New Branch',
                action: 'showNewBranchForm'
            },
            {
                name: 'New Sales Transaction',
                action: 'showNewTransactionForm'
            }
        ];

        vm.selectOption = selectOption;
        vm.cancel = cancel;

        function selectOption (opt) {
            modalServices.hideResolveModal(opt);
        }

        function cancel () {
            modalServices.closeModal();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mapLegendController', ['$rootScope', mapLegendController]);

    function mapLegendController ($rootScope) {
        var vm = this;

        vm.legendData = {};
        vm.close = close;

        initialize();

        function initialize () {
            console.log('map legend controller init');

            $rootScope.$on('compile-map-legend', function (e, params) {
                vm.legendData[params.type] = params.data;

                if (!$rootScope.showLegend) $rootScope.showLegend = true;
            });
        }

        function close () {
            $rootScope.showLegend = false;
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('mainController', ['$rootScope', 'APP_NAME', '$mdSidenav', 'userSessionService', 'alertServices', 'branchService',  'DEMO_MODE_MESSAGE','$http', 'mapToolsService', '$mdToast', 'placesService', 'gmapServices', mainController]);

    function mainController($rootScope, APP_NAME, $mdSidenav, userSessionService, alertServices, branchService, DEMO_MODE_MESSAGE, $http, mapToolsService, $mdToast, placesService, gmapServices) {
        var vm = this;

        $rootScope.appName = APP_NAME;

        $rootScope.showLegend = false;
        $rootScope.showTerritoryDetailBtn = false;
        $rootScope.showBranchCompareTable = false;

        /* Side Nav Menus */
        vm.menu = [];

        var MENU_SELECTIONS = [
            {
                link: '/',
                title: 'Channel Diversification',
                icon: 'track_changes',
                can: ['ADMIN', 'SALES']
            },
            {
                link: '/frauddetect',
                title: 'Fraud Detection',
                icon: 'fingerprint',
                can: ['ADMIN']
            },
            {
                link: '/productsaturation',
                title: 'Product Saturation',
                icon: 'assessment',
                can: ['ADMIN']
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app',
                can: ['ADMIN', 'SALES']
            }
        ];

        var branchId,
            branchMarker;

        $rootScope.showBranchCompareTable = false;

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');
        vm.onMenuItemClick = onMenuItemClick;
        vm.showBanchCompareTableAction = showBanchCompareTableAction;
        vm.showTerritoryPanelDetail = showTerritoryPanelDetail;
        vm.showLegendPanel = showLegendPanel;

        initialize();

        function initialize () {
            // loads user details
            $rootScope.$watch('currentUser', function(newValue){
                if (!newValue) return;
                vm.menu = getUserMenu(newValue);
            });

            // Compare Branch
            $(document).on('click', '#compare-branch-btn', function () {
                branchId = $(this).data('branch-id');
                branchMarker = branchService.getBranchById(branchId);

                if (branchMarker) {
                    $rootScope.$broadcast('close-territory-info-panel');
                    $rootScope.showBranchCompareTable = true;

                    var restObj = branchService.getRestangularObj(branchMarker.branch.id);

                    // get branch products
                    restObj.getList('products')
                        .then(function(response){
                            branchMarker.branch.products = angular.copy(response.plain());
                            $rootScope.$broadcast('new-compare-branch', branchMarker.branch);
                            branchService.dismissInfowindow();
                        });
                }
            });

            // get distance
            $(document).on('click', '#get-distance-branch-btn', function () {
                branchId = $(this).data('branch-id');
                branchMarker = branchService.getBranchById(branchId);

                $mdToast.show(
                    $mdToast.simple()
                        .textContent('Click POI to measure distance')
                        .position('bottom left')
                        .hideDelay(false)
                        .action('Close')
                ).then(function(response){
                    if (response == 'ok') mapToolsService.clearMeasurementLines();
                });

                branchService.dismissInfowindow();
                mapToolsService.activateMeasureDistanceTool(branchMarker.originalPosition);

                var poiClickListener = $rootScope.$on('poi-clicked', function(e,params){
                    placesService.dismissInfowindow();
                    mapToolsService.deactivateMeasureDistanceTool(params.position);
                    poiClickListener();
                });
            });

                // Edit Branch
            $(document).on('click', '#edit-branch-btn', function () {
                //branchId = $(this).data('branch-id');
                //console.log('edit branch with id = ' + branchId);
                // TODO: show edit modal
                //branchMarker = branchService.getBranchById(branchId);
                alertServices.showInfo(DEMO_MODE_MESSAGE);
            });

            // Delete Branch
            $(document).on('click', '#delete-branch-btn', function () {
                branchId = $(this).data('branch-id');

                alertServices.showConfirm('Delete Branch', 'Are your sure you want to delete this branch?', function (isConfirm) {
                    if (isConfirm) {
                        branchService.deleteBranch(branchId)
                            .then(function(response){
                                alertServices.showSuccess('Branch successfully deleted.');
                            });
                    }
                })
            });

            $rootScope.$on('modal-opened', function() {
                $rootScope.hasOpenedModal = true;
            });

            $rootScope.$on('modal-closed', function () {
                $rootScope.hasOpenedModal = false;
            });
        }

        function getUserMenu (user) {
            // TODO: this must come from backend
            var result = [];

            MENU_SELECTIONS.forEach(function(item){
                if (item.can.indexOf(user.role.toUpperCase()) > -1) return result.push(item);
            });

            return result;
        }

        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle();
            }
        }

        function onMenuItemClick (item) {
            if (item.title.toLowerCase() == 'logout') {
                // clean local storage
                userSessionService.userLogout();
            }

            isURLExist(item.link);
        }

        function showBanchCompareTableAction () {
            $rootScope.showBranchCompareTable = true;
        }

        function showTerritoryPanelDetail() {
            $mdSidenav('territoryInfoPanelSidenav')
                .open()
                .then(function () {
                    $rootScope.showTerritoryDetailBtn = false;
                    $rootScope.showGRDPPanel = true;
                });
        }

        function showLegendPanel() {
            $rootScope.showLegend = true;
        }

        function isURLExist (urlparam) {
            $http({
                method: "GET",
                url: urlparam
            }).then(function() {
                window.location.href = urlparam;
            }, function (error) {
                alertServices.showInfo(DEMO_MODE_MESSAGE);
            });
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('locationService', ['$q', 'gmapServices', locationService]);

    function locationService($q, gmapServices) {
        var service = {};

        service.getCurrentLocation = getCurrentLocation;
        service.showCurrentLocation = showCurrentLocation;
        service.showDraggableLocation = showDraggableLocation;

        function transformResponse (response) {
            return {
                lat: response.coords.latitude,
                lng: response.coords.longitude
            };
        }

        function getCurrentLocation () {
            if (!navigator.geolocation) {
                console.log('Browser doesnt support Geolocation');
                return false;
            }

            var dfd = $q.defer();

            navigator.geolocation.getCurrentPosition(function (response) {
                dfd.resolve(transformResponse(response));
            }, function (error){
                console.log('get current position error: ', error);
                dfd.reject(error);
            });

            return dfd.promise;
        }

        // Parameter must be a latLng
        function showCurrentLocation (position) {
            var latLng = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };

            var marker = gmapServices.showCurrentLocation(latLng);
            var offset = 0.002;


            gmapServices.panToOffsetLeft(latLng, offset);
            gmapServices.setZoomInDefault();

            return marker;
        }

        function showDraggableLocation () {
            var draggable = true,
                latLng = gmapServices.map.getCenter();

            var marker = gmapServices.showCurrentLocation(latLng, draggable);

            return marker;
        }

        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', 'MARKER_BASE_URL', gmapServices]);

    function gmapServices($log, $q, MARKER_BASE_URL) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(10.3194669, 123.9136565);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        service.directionsService = null;
        service.directionsDisplay = null;

        service.spiderifier = null;

        var spiderifyListener;

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.initializeGeocoder = initializeGeocoder;
        service.initializeDirectionsService = initializeDirectionsService;
        service.initializeDirectionsRenderer = initializeDirectionsRenderer;
        service.initializeDistanceMatrix = initializeDistanceMatrix;
        service.initializeIndividualDirectionsRenderer = initializeIndividualDirectionsRenderer;
        service.hideDirectionsRenderer = hideDirectionsRenderer;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.fitToBoundsByPolygon = fitToBoundsByPolygon;
        service.fitToBoundsLatLngArray = fitToBoundsLatLngArray;
        service.panToPolygon = panToPolygon;
        service.panToMarker = panToMarker;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.geocode = geocode;

        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.createMapIconLabel = createMapIconLabel;
        service.createHeatmap = createHeatmap;
        service.initializeSpiderify = initializeSpiderify;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            //$(myMapId).height($(window).height() - (42));
            $(myMapId).height($(window).height());

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //initializeGeocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function initializeGeocoder () {
            service.geocoder = new google.maps.Geocoder();
        }

        function initializeDirectionsService (opts) {
            if (!service.directionsService) service.directionsService = new google.maps.DirectionsService(opts);

            return service.directionsService;
        }

        function initializeIndividualDirectionsRenderer (opts) {
            var directionsRenderer = new google.maps.DirectionsRenderer(opts);

            directionsRenderer.setMap(service.map);

            return directionsRenderer;
        }

        function initializeDirectionsRenderer (opts) {
            if (!service.directionsDisplay) {
                service.directionsDisplay = new google.maps.DirectionsRenderer(opts);
            }

            if (!service.directionsDisplay.getMap()) {
                service.directionsDisplay.setMap(service.map);
            }

            return service.directionsDisplay;
        }

        function initializeDistanceMatrix () {
            if (service.distanceMatrix) return;

            service.distanceMatrix = new google.maps.DistanceMatrixService();
        }

        function hideDirectionsRenderer () {
            if (service.directionsDisplay) service.directionsDisplay.setMap(null);
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if (!(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function (infobox, index) {
                if (infobox) {
                    infobox.close();
                }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (!service.map) return;

            return service.addListener(service.map, eventName, callback);
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content, additionalOptions) {
            if (!service.apiAvailable()) return null;

            var opt = {content: content};

            if (additionalOptions) angular.merge(opt, additionalOptions);

            return new google.maps.InfoWindow(opt);
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            var marker = service.initMarker(_position, _color);

            //service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            return service.initMarker(_position, icon);
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if (_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else {
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function createCircle(centerLatLng, radiusParam, color) {
            return new google.maps.Circle({
                strokeColor: color || '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: color || '#FF0000',
                fillOpacity: 0.35,
                map: service.map,
                center: centerLatLng,
                radius: radiusParam
            });
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function fitToBoundsByPolygon (polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.map.fitBounds(bounds);
        }

        function fitToBoundsLatLngArray(latlngArray) {
            if (!service.map || !latlngArray.length) return;

            var bounds = new google.maps.LatLngBounds();

            latlngArray.forEach(function (path) {
                bounds.extend(path);
            });

            service.map.fitBounds(bounds);
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.map.setCenter(bounds.getCenter());
        }

        function panToMarker(marker) {
            if (!service.map || !marker) return;

            service.map.panTo(marker.getPosition());
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 2
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '10px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable()) google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable()) google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable()) google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function geocode(address) {
            if (!service.geocoder) {
                initializeGeocoder();
            }

            var dfd = $q.defer();

            service.geocoder.geocode({
                'address': address,
                componentRestrictions: {
                    country: 'PH'
                }
            }, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) {
                initializeGeocoder();
            }

            var dfd = $q.defer();

            service.geocoder.geocode({
                'latLng': latLng
            }, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if (layerName == 'meters') {
                return defaultStyle;
            } else if (layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if (layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId, opts) {
            var input = document.getElementById(elementId);
            var mergeOpts = angular.merge({
                types: ["geocode"]
            }, opts)

            var autocomplete = new google.maps.places.Autocomplete(input, mergeOpts);

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation(latLng, polygon) {
            if (!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent(obj, event) {
            google.maps.event.trigger(obj, 'click');
        }

        function createMapIconLabel(latLng, type, color) {
            return new Marker({
                map: service.map,
                position: latLng,
                icon: {
                    anchor: new google.maps.Point(-6, -10),
                    path: MAP_PIN,
                    fillColor: color || '#2ecc71',
                    fillOpacity: 1,
                    strokeColor: color ? '' : '#27ae60',
                    strokeWeight: color ? 0 : 1
                },
                map_icon_label: '<span class="map-icon map-icon-' + type + '"></span>'
            });
        }

        service.createFacilityMarker = createFacilityMarker;

        function createFacilityMarker(latLng) {
            return service.initMarker(latLng, 'resources/images/markers/wifi.png');
        }

        function createHeatmap (latLngArray, gradient) {
            return new google.maps.visualization.HeatmapLayer({
                data: latLngArray,
                map: service.map,
                gradient: gradient
            });
        }

        function initializeSpiderify () {
            if (!service.map) return;

            if (!service.spiderifier) service.spiderifier = new OverlappingMarkerSpiderfier(service.map, {
                nearbyDistance: 1,
                basicFormatEvents: true,
                markersWontMove: true,
                markersWontHide: false,
                keepSpiderfied: true
            });

            //var iconURL;
            //if (!spiderifyListener) {
            //    spiderifyListener = service.spiderifier.addListener('format', function (marker, status) {
            //        if (service.map.getZoom() < 10) {
            //            if (marker.getIcon() != marker['iconUrl']) {
            //                marker.setIcon({
            //                    url: marker['iconUrl']
            //                });
            //            }
            //            return;
            //        }
            //
            //        iconURL = (status == OverlappingMarkerSpiderfier.markerStatus.SPIDERFIED) ? marker['iconUrl']:
            //            (status == OverlappingMarkerSpiderfier.markerStatus.SPIDERFIABLE) ? MARKER_BASE_URL + 'symbol_plus.png':
            //                (status == OverlappingMarkerSpiderfier.markerStatus.UNSPIDERFIABLE) ? marker['iconUrl']:'';
            //        marker.setIcon({
            //            url: iconURL
            //        });
            //    });
            //}
            //window.oms = service.spiderifier;
        }

        return service;
    }
}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('formHelperService', [formHelperService]);

    function formHelperService () {
        var service = {};

        service.getDateFormatted = getDateFormatted;
        service.showFormErrors = showFormErrors;
        service.getFormattedErrors = getFormattedErrors;

        function getDateFormatted(date, withTime) {
            var dateStr = date.getFullYear() + '-' + (date.getMonth()+1) + '-' + date.getDate();

            //if (withTime) {
            //
            //}

            return dateStr;
        }

        // ex param. vm.form.$error
        function showFormErrors(formError) {
            angular.forEach(formError, function (field) {
                angular.forEach(field, function (errorField) {
                    errorField.$setTouched();
                })
            });
        }

        function getFormattedErrors(data) {
            var message = '',
                error;

            for (var key in data.errors) {
                error = data.errors[key];
                if (error.length) {
                    message += key.capitalize() + ' : ' + error[0] + '\n';
                }
            }

            return message;
        }


        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Filter', ['Restangular', Filter]);

    function Filter(Restangular) {
        var myModel = Restangular.all('filter');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'filter');
            }
        };

        Restangular.extendModel('filter', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            return Restangular.stripRestangular(model);
            //return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Boundary', ['Restangular', Boundary]);

    function Boundary(Restangular) {
        var myModel = Restangular.all('boundaries');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'boundaries');
            }
        };

        Restangular.extendModel('boundaries', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('boundariesService', ['Boundary', '$q', boundariesService]);

    function boundariesService (Boundary, $q) {
        var service = {};

        service.boundaries = [];

        service.loadBoundaries = loadBoundaries;
        service.getRestangularObj = getRestangularObj;

        function loadBoundaries(parentid) {
            var dfd = $q.defer();

            Boundary.customGET(null, {parent_id: parentid || null})
                .then(function (list) {
                    //console.log('load boundaries: ', list);
                    service.boundaries = list.plain().map(function (item) {
                        item['isExpanded'] = false;
                        return item;
                    });

                    dfd.resolve(list.plain());
                }, function (error) {
                    console.log('failed to load: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getRestangularObj (boundaryId) {
            return Boundary.cast(boundaryId);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        service.showDismissableToast = showDismissableToast;

        service.showConfirm = showConfirm;
        service.showSuccess = showSuccess;
        service.showInfo = showInfo;
        service.showError = showError;


        function showToast(message, position, delay) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(delay || 2000)
            );
        }

        function showBottomLeftToast(message, delay) {
            showToast(message, 'bottom left', delay);
        }

        function showTopRightToast(message, delay) {
            showToast(message, 'top right', delay);
        }

        function showDismissableToast (message, delay) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position('bottom left')
                    .hideDelay(delay)
            );
        }

        function showNoDataAvailablePrompt(entityName) {
            service.showBottomLeftToast('No ' + entityName + ' data available for this area.');
        }

        function showMessage(message, type, isAutoClose) {
            var opts = {
                title: message,
                type: type
            };

            if (isAutoClose) {
                angular.merge(opts, {timer: 1500, showConfirmButton: false});
            }

            return SweetAlert.swal(opts);
        }

        function showSuccess(message) {
            return showMessage(message, 'success');
        }

        function showError(message) {
            return showMessage(message, 'error');
        }

        function showInfo(message, isAutoClose) {
            return showMessage(message, 'info', isAutoClose);
        }

        function showConfirm (title, message, callbackOnConfirm) {
            return SweetAlert.swal({
                    title: title,
                    text: message,
                    type: "warning",
                    showCancelButton: true,
                    confirmButtonColor: "#DD6B55",
                    confirmButtonText: "Yes",
                    closeOnConfirm: true
                },
                callbackOnConfirm);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.productSaturation', [])

    ;

}());

(function(){
'use strict';

angular.module('demoApp.productSaturation')
    .controller('productSaturationPageController', ['$rootScope', 'gmapServices', 'modalServices', 'branchService', productSaturationPageController]);

    function productSaturationPageController ($rootScope, gmapServices, modalServices, branchService) {
        var vm = this;

        $rootScope.showProductSaturationSlider = false;
        vm.showSaturationInfo = false;

        var branchId,
            branchMarker;

        //var drawingManager, overlay;

        initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');

            $('#map-legend').addClass('map-legend-most-right');

            $(document).on('click', '#add-product-branch-btn', function () {
                branchId = $(this).data('branch-id');
                branchMarker = branchService.getBranchById(branchId);

                modalServices.showAddProductToBranch(branchMarker.branch)
                    .then(function(){

                    });
            });

            $rootScope.$on('product-saturation-numbers-update', function(e,params){
               vm.showSaturationInfo = angular.copy(params.data);
            });

            $rootScope.$on('show-product-saturation-slider', function(){
                $rootScope.showProductSaturationSlider = true;
            });


            /* for deletion only on branch, remove after */
            //drawingManager = new google.maps.drawing.DrawingManager({
            //    drawingControl: true,
            //    drawingControlOptions: {
            //        position: google.maps.ControlPosition.TOP_CENTER,
            //        drawingModes: ['polygon']
            //    }
            //});
            //drawingManager.setMap(gmapServices.map);
            //google.maps.event.addListener(drawingManager, 'overlaycomplete', function (event) {
            //    if (overlay) {
            //        overlay.setMap(null);
            //        overlay = null;
            //    }
            //
            //    overlay = event.overlay;
            //    var path = overlay.getPath().getArray().map(function(p){return p.toJSON();});
            //
            //    Branch.customPUT({boundary: path})
            //        .then(function(){
            //            overlay.setMap(null);
            //            overlay = null;
            //        },function(error){console.log('error: ',error);});
            //});
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.productSaturation')
    .controller('productSatSliderController', ['$rootScope', 'productSatService', productSatSliderController]);

    function productSatSliderController ($rootScope, productSatService) {
        var vm = this;

        vm.weeks = [];

        vm.slider = {
            currentVal: 0
        };

        var selected;
        var firstWeek;

        vm.currentSelectedWeek = '';

        vm.sliderChanged = sliderChanged;

        initialize();
        
        function initialize () {
            vm.weeks = productSatService.getFiveWeeksDuration(new Date());
            firstWeek = vm.weeks[0];
            sliderChanged();
        }

        function sliderChanged () {
           selected = vm.weeks[vm.slider.currentVal];
           selected.weekRangeStart = firstWeek.weekRangeStart;
           //selected.weekRangeStartFormatted = firstWeek.weekRangeStartFormatted;

           vm.currentSelectedWeek = selected.weekRangeStartFormatted + ' to ' + selected.weekRangeEndFormatted;

           $rootScope.$broadcast('product-saturation-time-slider-changes', {selectedWeek: selected});
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.productSaturation')
    .controller('productSatPanelController', ['$rootScope', 'Branch', 'branchService', '$q', 'Product', 'productSatService', 'SEMESTERS', 'salesTransactionService', productSatPanelController]);

    function productSatPanelController ($rootScope, Branch, branchService, $q, Product, productSatService, SEMESTERS, salesTransactionService) {
        var vm = this;

        var aborts;

        var branchTotalCount = 0;
        var list = [];

        vm.productList = [];
        vm.selectedDate = null;

        vm.filter = {
            q: '',
            selectedType: 'name',
            selectedProduct: null,
            semester: null
        };

        vm.hasProduct = {
            count: 0,
            percentage: 0
        };

        /* Slider Saturation Variables */

        vm.weeks = [];

        vm.slider = {
            currentVal: 0
        };

        var firstWeek;

        vm.currentSelectedWeek = '';

        /* Slider Sellout Variables */

        vm.selloutDates = [];

        vm.sliderSellout = {
            currentVal: 0
        };

        vm.toggleDataDisplayMessage = 'Show Heatmap';
        vm.toggleSaturationOrSalesDisplayMessage = 'Sales';

        vm.semesters = SEMESTERS;

        /* Scope Functions */
        vm.filterProductChanged = filterByProduct;
        vm.showBranch = showBranch;
        vm.sliderChanged = sliderChanged;
        vm.toggleDataDisplay = toggleDataDisplay;
        vm.toggleSaturationOrSalesChanged = toggleSaturationOrSalesChanged;
        vm.semesterChanged = semesterChanged;
        vm.sliderSelloutChanged = sliderSelloutChanged;

        initialize();

        function initialize () {
            Product.getList()
                .then(function (response) {
                    //vm.productList = vm.productList.concat(_.pluck(response.plain(), 'name'));
                    response.plain().forEach(function(item){
                        if (item.name) vm.productList.push(item);
                    });
                });

            // get branch total count
            Branch.customPUT({count_all: 'count_all'}).then(function(response){
               var res = response.plain();
               branchTotalCount = res.count;
            });

            Branch.getList()
                .then(function (response) {
                    branchService.loadMarkers(response.plain(), true);
                });

            salesTransactionService.getSelloutDistinctDates()
                .then(function(distinctDates){
                    vm.selloutDates = distinctDates;
                });

            vm.weeks = productSatService.getFiveWeeksDuration(new Date());
            firstWeek = vm.weeks[0];
            sliderChanged();

            //$rootScope.$on('product-saturation-time-slider-changes', function (e, params) {
            //    vm.selectedDate = angular.copy(params.selectedWeek);
            //
            //    if (!vm.filter.selectedProduct) return;
            //
            //    showResult(params.selectedWeek.weekRangeStart, params.selectedWeek.weekRangeEnd, vm.filter.selectedProduct);
            //});
        }

        function showResult (dateStart, dateEnd, selectedProduct) {
            aborts = $q.defer();

            list = [];

            Branch
                .withHttpConfig({timeout: aborts.promise})
                .getList({
                    start_date: dateStart,
                    end_date: dateEnd,
                    product: selectedProduct
                })
                .then(function (response) {
                    var result = response.plain();
                    var branchIds = result.map(function(item){return item.id;});
                    branchService.highlightMarkersOnSaturation(branchIds, vm.toggleDataDisplayModel);

                    list = angular.copy(result);

                    vm.hasProduct.count = list.length;
                    vm.hasProduct.percentage = Math.ceil(list.length / branchTotalCount * 100);
                    vm.hasProduct.fraction = list.length + ' / ' + branchTotalCount;
                    $rootScope.$broadcast('product-saturation-numbers-update', {data: vm.hasProduct});
                });
        }

        function showBranch (branchId) {
            branchService.triggerClickBranch(branchId);
        }

        function filterByProduct () {
            if (vm.toggleSaturationOrSalesModel) {
                semesterChanged(vm.filter.semester);
                return;
            }

            $rootScope.$broadcast('show-product-saturation-slider');

            if (!vm.filter.selectedProduct || !vm.selectedDate)  return;

            showResult(vm.selectedDate.weekRangeStart, vm.selectedDate.weekRangeEnd, vm.filter.selectedProduct);
        }

        function sliderChanged() {
            vm.selectedDate = angular.copy(vm.weeks[vm.slider.currentVal]);
            vm.selectedDate.weekRangeStart = firstWeek.weekRangeStart;
            //selected.weekRangeStartFormatted = firstWeek.weekRangeStartFormatted;

            vm.currentSelectedWeek = vm.selectedDate.weekRangeStartFormatted + ' to ' + vm.selectedDate.weekRangeEndFormatted;

            //$rootScope.$broadcast('product-saturation-time-slider-changes', {selectedWeek: selected});

            //vm.selectedDate = angular.copy(selected);

            if (!vm.filter.selectedProduct) return;

            showResult(vm.selectedDate.weekRangeStart, vm.selectedDate.weekRangeEnd, vm.filter.selectedProduct);
        }

        function toggleDataDisplay (flag) {
            vm.toggleDataDisplayMessage = flag ? 'Show Markers' : 'Show Heatmap';
            sliderChanged();
        }

        function toggleSaturationOrSalesChanged(flag) {
            vm.toggleSaturationOrSalesDisplayMessage = flag ? 'Saturation' : 'Sales';

            if (flag) {
                branchService.hideMarkers();
                if (vm.filter.semester) semesterChanged(vm.filter.semester);
                return;
            }

            branchService.hideHeatmap();
            branchService.showMarkers();

            vm.hasProduct.count = list.length;
            vm.hasProduct.percentage = Math.ceil(list.length / branchTotalCount * 100);
            vm.hasProduct.fraction = list.length + ' / ' + branchTotalCount;
            $rootScope.$broadcast('product-saturation-numbers-update', {data: vm.hasProduct});

        }

        function semesterChanged(semester) {
            branchService.getSelloutsByProduct(semester, vm.filter.selectedProduct)
                .then(function (sellouts) {
                    console.log('sellouts by product: ', sellouts);
                    branchService.displaySellouts(sellouts);

                    vm.hasProduct.count = sellouts.length;
                    vm.hasProduct.percentage = Math.ceil(sellouts.length / branchTotalCount * 100);
                    vm.hasProduct.fraction = sellouts.length + ' / ' + branchTotalCount;
                    $rootScope.$broadcast('product-saturation-numbers-update', {data: vm.hasProduct});
                });

        }

        var selloutDate;

        function sliderSelloutChanged () {
            selloutDate = vm.selloutDates[vm.sliderSellout.currentVal];

            vm.selectedSelloutDate = moment(selloutDate).format('MMMM YYYY');;

            branchService.getSelloutsByProduct(selloutDate, vm.filter.selectedProduct)
                .then(function (sellouts) {
                    console.log('sellouts by product: ', sellouts);
                    branchService.displaySellouts(sellouts);

                    vm.hasProduct.count = sellouts.length;
                    vm.hasProduct.percentage = Math.ceil(sellouts.length / branchTotalCount * 100);
                    vm.hasProduct.fraction = sellouts.length + ' / ' + branchTotalCount;
                    $rootScope.$broadcast('product-saturation-numbers-update', {data: vm.hasProduct});
                });

            vm.currentSelectedSelloutDate = angular.copy(vm.sliderSellout.currentVal);
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.productSaturation')
    .factory('productSatService', ['Product', '$q', productSatService]);

    function productSatService (Product, $q) {
        var service = {};

        service.products = [];

        service.getProducts = getProducts;
        service.getProductTypes = getProductTypes;
        service.saveProduct = saveProduct;
        service.getFiveWeeksDuration = getFiveWeeksDuration;

        function getProducts () {
            var dfd = $q.defer();

            Product.getList()
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getProductTypes () {
            var dfd = $q.defer();

            Product.all('types')
                .getList()
                .then(function(list){
                   var types = _.pluck(list.plain(), 'type');
                    dfd.resolve(types);
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function saveProduct (data, id) {
            var dfd = $q.defer();

            if (id) { // update
                Product.cast(id)
                    .customPUT(data)
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            } else { // insert
                Product.post(data)
                    .then(function (response) {
                        var resp = response.plain();
                        console.log('post product ', resp);
                        dfd.resolve(resp);
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function getFiveWeeksDuration (date) {
            var result = [];
            //var currentMomentData = moment(date);
            var currentMomentData = moment('2016-01-01');
            var formatDate = 'YYYY-MM-DD',
                formatDateHuman = 'dddd, MMMM Do YYYY';

            result.push({
                week: 0,
                weekRangeStart: currentMomentData.startOf('week').format(formatDate),
                weekRangeEnd: currentMomentData.endOf('week').format(formatDate),
                weekRangeStartFormatted: currentMomentData.startOf('week').format(formatDateHuman),
                weekRangeEndFormatted: currentMomentData.endOf('week').format(formatDateHuman)
            });

            for (var i=1; i<5; i++) {
                currentMomentData = currentMomentData.endOf('week').add(1, 'days');
                result.push({
                    week: i,
                    weekRangeStart: currentMomentData.startOf('week').format(formatDate),
                    weekRangeEnd: currentMomentData.endOf('week').format(formatDate),
                    weekRangeStartFormatted: currentMomentData.startOf('week').format(formatDateHuman),
                    weekRangeEndFormatted: currentMomentData.endOf('week').format(formatDateHuman)
                });
            }

            return result;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.productSaturation')
        .factory('Product', ['Restangular', Product]);

    function Product(Restangular) {
        var myModel = Restangular.all('products');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'products');
            }
        };

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.productSaturation')
    .controller('newProductController', ['productSatService', 'formHelperService', 'modalServices', 'alertServices', newProductController]);

    function newProductController (productSatService, formHelperService, modalServices, alertServices) {
        var vm = this;

        vm.form = {};

        vm.maxDate = new Date();

        vm.productTypes = [];

        vm.product = {};

        vm.save = save;
        vm.close = close;

        initialize();
        
        function initialize () {
            productSatService.getProductTypes()
                .then(function(types){
                   vm.productTypes = angular.copy(types);
                });
        }

        function save() {
            if (!vm.form.$valid) {
                formHelperService.showFormErrors(vm.form.$error);
                return;
            }

            var formData = angular.copy(vm.product);
            //console.log('save product form data: ', formData);

            productSatService.saveProduct(formData)
                .then(function(response){
                    alertServices.showSuccess('New Product saved.');
                    modalServices.hideResolveModal(response);
                }, function(error){
                    console.log('save product error: ', error);
                    // show errors
                    alertServices.showError(formHelperService.getFormattedErrors(error.data));
                });
        }

        function close() {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.productSaturation')
    .controller('addProductToBranchController', ['branch', 'productSatService', 'modalServices', 'alertServices', 'Branch', 'formHelperService', addProductToBranchController]);

    function addProductToBranchController (branch, productSatService, modalServices, alertServices, Branch, formHelperService) {
        var vm = this;

        var branchRest;

        vm.tableHeading = ['name', 'type', 'cost'];

        vm.deliveryDate = null;
        vm.selectedProduct = [];

        vm.branch = {};

        vm.products = [];

        vm.addProduct = addProduct;
        vm.save = save;
        vm.close = close;

        initialize();
        
        function initialize () {
            vm.branch = angular.copy(branch);

            productSatService.getProducts()
                .then(function(list){

                    branchRest = Branch.cast(branch.id);

                    branchRest.getList('products')
                        .then(function (response) {
                            var resp = response.plain();
                            var productIds = _.pluck(resp, 'productid');

                            vm.products = angular.copy(list.map(function (item) {
                                item.added = productIds.indexOf(item.id) > -1;
                                return item;
                            }));

                        });

                });
        }

        function addProduct (item) {
            var index = vm.selectedProduct.indexOf(item.id);

            if (index > -1) {
                //vm.selectedProduct.splice(index, 1);
                //item.added = false;
                return;
            }

            item.added = true;
            vm.selectedProduct.push(item.id);
        }

        function save() {
            var data = {
                'date_released': formHelperService.getDateFormatted(vm.deliveryDate),
                'products': vm.selectedProduct
            };

            console.log('save: ',data);

            branchRest.all('products').post(data)
                .then(function(response){
                    console.log('save products branch: ',response.plain());
                    alertServices.showSuccess('Products added to Branch.');
                    modalServices.hideResolveModal(response.plain());
                });
        }

        function close() {
            modalServices.closeModal();
        }
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.fraud', [])

        .constant('TRANSACTION_STATUSES', {
            'CLEARED': 'CLEARED',
            'FRAUD': 'FRAUD',
            'INVESTIGATING': 'INVESTIGATING'
        })

    ;

}());

(function(){
'use strict';

angular.module('demoApp.fraud')
    .controller('fraudReportTableController', ['data', 'modalServices', 'gmapServices', '$q', '$interval', 'userSessionService', fraudReportTableController]);

    function fraudReportTableController (data, modalServices, gmapServices, $q, $interval, userSessionService) {
        var vm = this;

        var visualization;

        var exceptionColumns = [];
        var exceptionData = [];

        vm.showOnMapIsLoading = false;

        vm.viewOnMap = viewOnMap;
        vm.close = close;

        initialize();

        function initialize () {
            //console.log('fraudReportTableController data: ',data);

            drawConsolidateData();
            drawExceptions();
        }

        function getDataReverseGeocoded () {
            var dfd = $q.defer();
            var list = [];

            var i = 0, item;
            var interval = $interval(function(){
                item = exceptionData[i];

                for (var k in item) {
                    item['latlng'] = null;
                    if (k.indexOf('address') > -1 && item[k]) {
                            gmapServices.geocode(item[k])
                                .then(function (results) {
                                    console.log('geocode response: ', results);
                                    if (results.length) item['latlng'] = results[0].geometry.location.toJSON();
                                }, function (error) {
                                    console.log('error: ', error);
                                });
                    }
                }

                list.push(item);
                i++;

                if (i >= exceptionData.length) {
                    $interval.cancel(interval);
                    interval = null;
                    dfd.resolve(list);
                }
            }, 250);


            return dfd.promise;
        }

        function viewOnMap () {
            vm.showOnMapIsLoading = true;

            var fraudData = userSessionService.getFraudData();

            if (fraudData) {
                modalServices.hideResolveModal(fraudData);
                vm.showOnMapIsLoading = false;
                return;
            }

            getDataReverseGeocoded()
                .then(function(data){
                    userSessionService.saveFraudData(data);
                    modalServices.hideResolveModal(data);
                })
                .finally(function(){
                    vm.showOnMapIsLoading = false;
                });
        }

        function close () {
            modalServices.closeModal();
        }

        function drawConsolidateData() {
            var queryStr = 'https://spreadsheets.google.com/tq?';
                queryStr += 'key=16Fy3dwBGPXg3IgQh63yVZ_4q0zX70GD5H2JGNhn-Imw';
                // first worksheet id
                queryStr += '&gid=956680783';
                queryStr += '&output=html';

            var query = new google.visualization.Query(queryStr);
            query.setQuery('SELECT * WHERE W = "Yes" LIMIT 500');
            query.send(function(response){
                handleQueryResponse(response, 'consolidate-container');
            });
        }

        function getColumnNames (list) {
            return list.map(function(item){
               return item.label.trim().toLowerCase();
            });
        }

        function extractData (list) {
            exceptionData = [];
            var result = [],
                obj,
                col;

            list.forEach(function(item){
                obj = {};
                item.c.forEach(function(itemc, index){
                    col = exceptionColumns[index];
                    obj[col] = itemc && itemc.hasOwnProperty('v')
                                                   ? (itemc.hasOwnProperty('f') ? itemc.f : itemc.v)
                                                   : '';
                });
                result.push(obj);
            });

            return result;
        }

        function drawExceptions() {
            var queryStr = 'https://spreadsheets.google.com/tq?';
            queryStr += 'key=16Fy3dwBGPXg3IgQh63yVZ_4q0zX70GD5H2JGNhn-Imw';

            // second worksheet id
            queryStr += '&gid=585256121';
            queryStr += '&output=html';

            var query = new google.visualization.Query(queryStr);
            query.setQuery('SELECT *');
            query.send(function (response) {
                var data = handleQueryResponse(response, 'exceptions-container');
                exceptionColumns = getColumnNames(data.Mf);
                exceptionData = extractData(data.Nf);
                //console.log('exception data: ',exceptionData);
            });
        }

        function handleQueryResponse(response, elementId) {
            //console.log('handleQueryResponse '+elementId,response);
            if (response.isError()) {
                alert('There was a problem with your query: ' + response.getMessage() + ' ' + response.getDetailedMessage());
                return;
            }

            var data = response.getDataTable();
            //console.log('data table: ',data);

            visualization = new google.visualization.Table(document.getElementById(elementId));
            visualization.draw(data, {
                legend: 'top'
            });

            return data;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.fraud')
    .controller('fraudPanelController', ['$rootScope', 'fraudService', 'alertServices', '$timeout', 'modalServices', 'userSessionService', '$mdDateRangePicker', 'salesTransactionService', 'userResourcesService', '$q', 'gmapServices', 'userTerritoriesService', fraudPanelController]);

    function fraudPanelController ($rootScope, fraudService, alertServices, $timeout, modalServices, userSessionService, $mdDateRangePicker, salesTransactionService, userResourcesService, $q, gmapServices, userTerritoriesService) {
        var vm = this;

        var userTerritoryPolygons = [];

        vm.listOfDays = [];
        vm.dataIsLoaded = true;

        vm.filter = {
            empId: null
        };

        vm.employeeList = [];
        vm.transactions = [];

        vm.maxDate = new Date();

        vm.selectedDate = {
            formatted: '',
            start: null,
            end: null
        };

        vm.selectedRange = {
            selectedTemplate: 'TW',
            selectedTemplateName: 'This Week',
            dateStart: null,
            dateEnd: null,
            showTemplate: false,
            fullscreen: false,
            disableTemplates: "NW",
            maxRange: new Date(),
            onePanel: true
        };

        //var sampleDataStartDate = new Date(2017, 1, 8),
        //    sampleDataEndDate = new Date(2017, 1, 10);


        var sampleDataStartDate = new Date(2016, 5, 1),
            sampleDataEndDate = new Date(2016, 11, 31);

        vm.uploadHasResponse = true;
        vm.frauds = [];

        vm.uploadFraudData = uploadFraudData;
        vm.showFraudDetail = showFraudDetail;
        //vm.showFraudTransactions = showFraudTransactions;
        vm.pickDateRange = pickDateRange;
        vm.onClickTransaction = onClickTransaction;
        vm.employeeFilterChanged = employeeFilterChanged;
        vm.getTransactionByDate = getTransactionByDate;
        vm.returnToDayList = returnToDayList

        initialize();

        function initialize () {
            var fraudData = userSessionService.getFraudData();
            if (fraudData) {
                vm.frauds = fraudService.showFraudDataOnMap(fraudData);
            }

            vm.selectedRange.dateStart = sampleDataStartDate;
            vm.selectedRange.dateEnd = sampleDataEndDate;

            userResourcesService.getEmployees()
                .then(function(list){
                    vm.employeeList = angular.copy(list);

                    $timeout(function(){
                        vm.filter.empId = '2';

                        $timeout(function () {
                            setDateGetData(vm.selectedRange.dateStart, vm.selectedRange.dateEnd);
                            getArrayOfDateFromRange(vm.selectedRange.dateStart, vm.selectedRange.dateEnd)
                                .then(function (list) {
                                    vm.listOfDays = list;

                                    getSalesTransactions();
                                    showEmployeeTerritory();
                                });
                        }, 500);
                    }, 1000);
                });

            $rootScope.$on('update-transacton-status', function(e, params){
                var foundIndex = _.findIndex(vm.transactions, {id: params.id});
                if (foundIndex > -1) vm.transactions[foundIndex].status = params.status;
            });
        }

        //function showFraudTransactions () {
        //    modalServices.showFraudResult()
        //        .then(function (datalist) {
        //            vm.frauds = fraudService.showFraudDataOnMap(datalist);
        //        });
        //}

        function uploadFraudData(file, errFiles, event) {
            event.stopPropagation();

            if (!file || errFiles.length) {
                alertServices.showError('File is invalid.\nAccepts excel file only.\n .xlsx, .xls');
                return;
            }

            vm.uploadHasResponse = false;

            fraudService.uploadEmployeeTransactionData(file)
                .then(function (response) {
                    console.log('successfully uploaded employee data: ', response);
                        //$timeout(function(){
                        //    vm.uploadHasResponse = true;
                            alertServices.showInfo('Data uploaded.', true);
                        //}, 3000);
                }, function (error) {
                    console.log('error on uploading employee data: ', error);
                })
                .finally(function () {
                    $timeout(function () {
                        vm.uploadHasResponse = true;
                    }, 1000);
                });
        }

        function showFraudDetail(item) {
            fraudService.showMarker(item.id);
        }

        function getSalesTransactions () {
            var dfd = $q.defer();

            vm.dataIsLoaded = false;

            vm.transactions = [];
            salesTransactionService.resetMarkers();

            fraudService.getTransactionsWithinDateRange(vm.selectedDate.start, vm.selectedDate.end, vm.filter.empId)
                .then(function(list){
                   vm.transactions = [];
                   list.forEach(function(item){
                       if (item.end_point_latlng) {
                           vm.transactions.push(item);
                       }
                   });
                    //salesTransactionService.initMarkers(list, true);
                    salesTransactionService.initMarkers(vm.transactions, true);
                    dfd.resolve(vm.transactions);
                }).finally(function(){
                    vm.dataIsLoaded = true;
                });

            return dfd.promise;
        }

        function setDateGetData (dateStart, dateEnd) {
            vm.selectedDate = {};

            var momentDateStart = moment(dateStart);
            var dateStartStr = momentDateStart.format('MMM D, YYYY');

            vm.selectedDate.start = momentDateStart.format('YYYY-MM-DD');

            var dateEndStr;

            if (dateEnd) {
                var momentDateEnd = moment(dateEnd);
                dateEndStr = momentDateEnd.format('MMM D, YYYY');
                vm.selectedDate.end = momentDateEnd.format('YYYY-MM-DD');
            }

            vm.selectedDate.formatted = dateStart && dateEnd
                                        ? dateStartStr + ' - ' + dateEndStr
                                        : dateStartStr;

        }

        function getArrayOfDateFromRange (dateStart, dateEnd) {
            var dfd = $q.defer();

            //console.log('getArrayOfDateFromRange', dateStart, dateEnd);

            var dateArray = [],
                idx;

            while(dateStart <= dateEnd) {
                dateArray.push({
                    date: dateStart,
                    date_formatted: moment(dateStart).format('ddd MMM D, YYYY'),
                    date_param: moment(dateStart).format('YYYY-MM-DD')
                });
                dateStart = dateStart.addDays(1);
            }

            var dateArrayParam = dateArray.map(function (item) {
                return item.date_param;
            });

            var promises = [];

            promises.push(
                fraudService.getDaysWithFraudTransactionsCount(dateArrayParam, vm.filter.empId)
                    .then(function (fraudListTransactions) {
                        //console.log('getDaysWithFraudTransactionsCount list: ', fraudListTransactions);
                        dateArray.forEach(function (dateItm, listIndex) {
                            idx = _.findIndex(fraudListTransactions, {date_param: dateItm.date_param});
                            if (idx > -1 && fraudListTransactions[idx].count) dateArray[listIndex]['fraudcount'] = fraudListTransactions[idx].count;
                        });
                    })
            );

            promises.push(
                fraudService.getDaysWithInvestigatedTransactionsCount(dateArrayParam, vm.filter.empId)
                    .then(function (investigatedListTransactions) {
                        //console.log('getDaysWithInvestigatedTransactionsCount: ', investigatedListTransactions);
                        dateArray.forEach(function (dateItm, listIndex) {
                            idx = _.findIndex(investigatedListTransactions, {date_param: dateItm.date_param});
                            if (idx > -1 && investigatedListTransactions[idx].count) dateArray[listIndex]['investigatedcount'] = investigatedListTransactions[idx].count;
                        });
                    })
            );

            promises.push(
                fraudService.getDaysWithClearedTransactionsCount(dateArrayParam, vm.filter.empId)
                    .then(function (clearedListTransactions) {
                        //console.log('getDaysWithClearedTransactionsCount: ', clearedListTransactions);
                        dateArray.forEach(function (dateItm, listIndex) {
                            idx = _.findIndex(clearedListTransactions, {date_param: dateItm.date_param});
                            if (idx > -1 && clearedListTransactions[idx].count) dateArray[listIndex]['clearedcount'] = clearedListTransactions[idx].count;
                        });
                    })
            );


            $q.all(promises)
                .finally(function(){
                    var newarray = [];
                    dateArray.map(function (item) {
                        if (item.hasOwnProperty('fraudcount')
                            || item.hasOwnProperty('investigatedcount')
                            || item.hasOwnProperty('clearedcount')) {
                            newarray.push(item);
                        }
                    });
                    dfd.resolve(newarray);
                });

            return dfd.promise;
        }

        function showResult (result) {
            listOfDaysTemp = [];
            vm.listOfDays = [];

            vm.selectedRange = result;

            if (vm.selectedRange.dateStart == vm.selectedRange.dateEnd) {
                //console.log('range is same day');
                setDateGetData(vm.selectedRange.dateStart);
            } else {
                setDateGetData(vm.selectedRange.dateStart, vm.selectedRange.dateEnd);
                getArrayOfDateFromRange(vm.selectedRange.dateStart, vm.selectedRange.dateEnd)
                    .then(function(list){
                        vm.listOfDays = list;
                    });
            }

            getSalesTransactions();
        }

        function pickDateRange($event, showTemplate) {
            vm.selectedRange.showTemplate = showTemplate;

            $mdDateRangePicker.show({
                targetEvent: $event,
                model: vm.selectedRange
            }).then(function (result) {
                if (result) showResult(result);
                //alertServices.showInfo('Functionality will be included on Production');
            })
        }

        function onClickTransaction (item) {
            salesTransactionService.showMarkerById(item.id);
        }

        var listOfDaysTemp = [];

        function employeeFilterChanged () {
            getSalesTransactions();
            showEmployeeTerritory();
        }

        function hideUserTerritories () {
            userTerritoryPolygons.forEach(function(polygon){
                polygon.setMap(null);
                polygon = null;
            });
            userTerritoryPolygons = [];
        }

        function showEmployeeTerritory () {
            hideUserTerritories();

            userResourcesService.getUserTerritories(vm.filter.empId)
                .then(function(polygonResults){
                    polygonResults.forEach(function(data){
                        userTerritoryPolygons.push(userTerritoriesService.showTerritoryPolygon(data.territory.geom));
                    });
                });
        }

        function getTransactionByDate (dateItem) {
            //console.log('getTransactionByDate: ', dateItem);

            setDateGetData(dateItem.date);

            listOfDaysTemp = angular.copy(vm.listOfDays);
            vm.listOfDays = [];

            getSalesTransactions()
                .then(function(list){
                  //console.log('list: ',list);
                    gmapServices.fitToBoundsLatLngArray(list.map(function(itm){return itm.end_point_latlng;}));
                });
        }

        function returnToDayList () {
            salesTransactionService.resetTransactionVisuals();
            if (listOfDaysTemp.length) vm.listOfDays = angular.copy(listOfDaysTemp);
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.fraud')
    .controller('fraudPageController', ['$rootScope', 'gmapServices', 'salesTransactionService', 'TRANSACTION_STATUSES', 'alertServices', fraudPageController]);

    function fraudPageController ($rootScope, gmapServices, salesTransactionService, TRANSACTION_STATUSES, alertServices) {
        var vm = this;

        var timeoutId;
        var remarksContent;

        initialize();

        function initialize () {

            $(document).on('change paste keyup', 'textarea#transaction-remarks-textarea', function () {
                var id = $(this).data('transaction-id');
                remarksContent = $(this).val();
                clearTimeout(timeoutId);
                timeoutId = setTimeout(function () {
                    salesTransactionService.saveTransactionRemarks(id, remarksContent)
                        .then(function(response){
                            $(document)
                                .find('#transaction-remarks-textarea-response')
                                .text('Saved. ' + new Date().toLocaleTimeString())
                                .fadeIn()
                                .css({'display': 'inline'})
                                .delay(5000)
                                .queue(function(n){
                                    $(this).fadeOut();
                                    n();
                                });
                        });
                }, 1000);
            });

            // Mark Fraud
            $(document).on('click', '#mark-fraud-btn', function () {
                var id = $(this).data('transaction-id');

                salesTransactionService.updateTransactionStatus(id, TRANSACTION_STATUSES.FRAUD)
                    .then(function(){
                        alertServices.showBottomLeftToast('Transaction marked as FRAUD.');
                        $rootScope.$broadcast('update-transacton-status', {'id': id, 'status': TRANSACTION_STATUSES.FRAUD});
                    });
            });

            // mark cleared
            $(document).on('click', '#mark-cleared-btn', function () {
                var id = $(this).data('transaction-id');

                salesTransactionService.updateTransactionStatus(id, TRANSACTION_STATUSES.CLEARED)
                    .then(function(){
                        alertServices.showBottomLeftToast('Transaction marked as CLEARED.');
                        $rootScope.$broadcast('update-transacton-status', {'id': id, 'status': TRANSACTION_STATUSES.CLEARED});
                    });
            });

            // investigate
            $(document).on('click', '#mark-investigate-btn', function () {
                var id = $(this).data('transaction-id');

                salesTransactionService.updateTransactionStatus(id, TRANSACTION_STATUSES.INVESTIGATING)
                    .then(function(){
                        alertServices.showBottomLeftToast('Transaction marked as for INVESTIGATION.');
                        $rootScope.$broadcast('update-transacton-status', {'id': id, 'status': TRANSACTION_STATUSES.INVESTIGATING});
                    });
            });

            gmapServices.createMap('map-canvas');
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.fraud')
    .factory('fraudService', ['$q', 'Fraud', 'gmapServices', 'SalesTransaction', 'salesTransactionService', 'COVERAGE_DATA', fraudService]);

    function fraudService ($q, Fraud, gmapServices, SalesTransaction, salesTransactionService, COVERAGE_DATA) {
        var service = {};

        //var fraudMarkerUrl = MARKER_BASE_URL + 'fraud.png';
        var fraudMarkers = [],
            fraudInfowindow;

        service.uploadEmployeeTransactionData = uploadEmployeeTransactionData;
        //service.showFraudDataOnMap = showFraudDataOnMap;
        service.showMarker = showMarker;
        service.getTransactionsWithinDateRange = getTransactionsWithinDateRange;
        service.getDaysWithFraudTransactionsCount = getDaysWithFraudTransactionsCount;
        service.getDaysWithClearedTransactionsCount = getDaysWithClearedTransactionsCount;
        service.getDaysWithInvestigatedTransactionsCount = getDaysWithInvestigatedTransactionsCount;
        service.getSampleData = getSampleData;

        function uploadEmployeeTransactionData (file) {
            var dfd = $q.defer();

            if (!file) {
                dfd.reject();
            } else {
                file.upload = Fraud.uploadEmployeeTransactionData(file);

                file.upload.then(function (response) {
                        file.result = response.data;
                        dfd.resolve(response.data);
                }, function (error) {
                    dfd.reject(error);
                }, function (evt) {
                    file.progress = Math.min(100, parseInt(100.0 *
                        evt.loaded / evt.total));

                });
            }

            return dfd.promise;
        }

        //function showFraudDataOnMap (list) {
        //    if (!fraudInfowindow) fraudInfowindow = gmapServices.createInfoWindow('', {pixelOffset: new google.maps.Size(0, 20)});
        //
        //    var marker;
        //
        //    // TODO: need to fix date and time before to add on info
        //    var except = ['latlng'];
        //
        //    list.forEach(function(item, idx){
        //       if (item.latlng) {
        //           marker = gmapServices.initMarker(
        //               item.latlng,
        //               fraudMarkerUrl
        //           );
        //
        //           marker.content = '<div>';
        //           for (var k in item) {
        //               if (except.indexOf(k) === -1) {
        //                   marker.content += '<p style="margin:0;padding:0;"><b>' + k.capitalize() + '</b> : ' + (item[k] ? item[k] : '') + '</p>';
        //               }
        //
        //               if (k.indexOf('address') > -1) {
        //                   item['merchant_address'] = angular.copy(item[k]);
        //                   delete item[k];
        //               } else if(k.indexOf('station') > -1) {
        //                   item['merchant_name'] = angular.copy(item[k]);
        //                   delete item[k];
        //               } else if(k == 'transaction type') {
        //                   item['type'] = angular.copy(item[k])
        //                   delete item[k];
        //               }
        //           }
        //           marker.content += '</div>';
        //
        //           marker.id = idx;
        //           marker.data = angular.copy(item);
        //
        //           gmapServices.addListener(marker, 'click', function () {
        //               fraudInfowindow.open(gmapServices.map, this);
        //               fraudInfowindow.setContent(this.content);
        //           });
        //
        //           fraudMarkers.push(marker);
        //       }
        //    });
        //
        //    return fraudMarkers;
        //}

        function showMarker (id) {
            var found = _.findWhere(fraudMarkers, {id: id});
            if (found) {
                if (!found.getMap()) found.setMap(gmapServices.map);

                gmapServices.setZoomIfGreater(14);
                gmapServices.panToMarker(found);

                // show infowindow
                gmapServices.triggerEvent(found, 'click');
            }
        }

        function getTransactionsWithinDateRange(dateStart, dateEnd, empId) {
            //console.log('getTransactionsWithinDateRange: ', dateStart, dateEnd, empId);
            var dfd = $q.defer();

            var dateMoment;

            SalesTransaction.getList({'start_date': dateStart, 'end_date': dateEnd, 'emp_id': empId})
                .then(function (response) {
                    var result = response.plain().map(function (item) {
                        dateMoment = moment(item.transaction_date);
                        item.transaction_date_formatted = dateMoment.format('dddd, MMMM DD, YYYY h:mm:ss A');
                        item.icon = salesTransactionService.getIconByType(item.type);
                        return item;
                    });
                    dfd.resolve(result);
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getDaysWithFraudTransactionsCount (datesArray, empId) {
            var dfd = $q.defer();

            SalesTransaction.customPUT({'dates': datesArray.join('|'), 'emp_id': empId})
                .then(function(response){
                    //var result = response.plain().map(function (item) {
                    //    dateMoment = moment(item.transaction_date);
                    //    item.transaction_date_formatted = dateMoment.format('dddd, MMMM DD, YYYY h:mm:ss A');
                    //    item.icon = salesTransactionService.getIconByType(item.type);
                    //    return item;
                    //});
                    dfd.resolve(response.plain());
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getDaysWithClearedTransactionsCount(datesArray, empId) {
            var dfd = $q.defer();

            SalesTransaction.customPUT({'dates': datesArray.join('|'), 'emp_id': empId, 'transaction_status': 'cleared'})
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getDaysWithInvestigatedTransactionsCount(datesArray, empId) {
            var dfd = $q.defer();

            SalesTransaction.customPUT({
                    'dates': datesArray.join('|'),
                    'emp_id': empId,
                    'transaction_status': 'investigating'
                })
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getSampleData () {
            var data = [];

            return data.concat(COVERAGE_DATA);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.fraud')
        .factory('Fraud', ['Restangular', 'Upload', Fraud]);

    function Fraud(Restangular, Upload) {
        var myModel = Restangular.all('frauds');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'frauds');
            },

            uploadEmployeeTransactionData: function (fileParam) {
                var uploadUrl = myModel.getRestangularUrl() + '/' + 'upload';
                return Upload.upload({
                    url: uploadUrl,
                    method: 'POST',
                    data: {file: fileParam}
                });
            }
        };

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

var coverageIcon = {
    color: "#e67e22",
    icon: "flag",
    markerIcon: "embassy"
};

var coverageSampleData = [
    {
        id: 27,
        userid: 2,
        merchantid: 296,
        address: "B. Rodriguez St, Cebu City, Cebu",
        type: "COVERAGE",
        cost: 1250,
        description: 'Product presentation',
        transaction_date: "2017-02-09T14:35:20",
        travel_time_in_minutes: 40,
        average_travel_time_in_minutes: 45,
        start_point_latlng: {
            lat: 10.306362,
            lng: 123.8995343
        },
        end_point_latlng: {
            lat: 10.3080171,
            lng: 123.8893832
        },
        icon: angular.merge({}, coverageIcon, {color: '#e74c3c'}),
        merchant: {
            address: "B. Rodriguez St, Cebu City, Cebu",
            latlng: {
                lat: 10.3080171,
                lng: 123.8893832
            },
            name: "VUIDEZ,LOLITA",
            specialty: "GENERAL MEDICINE"
        },
        remarks: 'employee is on leave during transaction date',
        status: 'FRAUD'
    },
    {
        id: 26,
        userid: 2,
        merchantid: 227,
        address: "BALIUAG",
        type: "COVERAGE",
        cost: 1550.75,
        description: 'Amoclav  dispensing deal',
        transaction_date: "2017-02-08T10:08:15",
        travel_time_in_minutes: 120,
        average_travel_time_in_minutes: 100,
        start_point_latlng: {
            lat: 10.306362,
            lng: 123.8995343
        },
        end_point_latlng: {
            lat: 10.2898386,
            lng: 123.9646196
        },
        icon: angular.merge({}, coverageIcon, {color: '#e74c3c'}),
        merchant: {
            address: "Maximo V. Patalinhug Jr. Avenue, Lapu-Lapu City, Cebu",
            latlng: {
                lat: 10.2898386,
                lng: 123.9646196
            },
            name: "ENRIQUEZ,MA. CONSUELO",
            specialty: "GENERAL MEDICINE"
        },
        remarks: 'out of territory',
        status: 'FRAUD'
    },
    {
        id: 28,
        userid: 2,
        merchantid: null,
        address: "B. Rodriguez St, Cebu City, Cebu",
        type: "FLEET",
        cost: 2000,
        description: '',
        transaction_date: "2017-02-07T14:05:00",
        travel_time_in_minutes: 40,
        average_travel_time_in_minutes: 45,
        start_point_latlng: null,
        end_point_latlng: {
            lat: 10.3083076,
            lng: 123.8894964
        },
        icon: {
            markerIcon: 'gas-station',
            color: '#f39c12',
            icon: 'local_gas_station'
        },
        merchant: null,
        remarks: 'less kilometers traveled from transactions over gas expenses',
        status: 'INVESTIGATING'
    },
    {
        id: 23,
        userid: 2,
        merchantid: 224,
        address: "Don Mariano Cui St, Cebu City, Cebu",
        type: "COVERAGE",
        cost: 450.00,
        description: 'Product presentation',
        transaction_date: "2017-02-06T14:35:20",
        travel_time_in_minutes: 45,
        average_travel_time_in_minutes: 60,
        start_point_latlng: {
            lat: 10.306362,
            lng: 123.8995343
        },
        end_point_latlng: {
            lat: 10.3098146,
            lng: 123.8872474
        },
        icon: angular.merge({}, coverageIcon, {color: '#95a5a6'}),
        merchant: {
            address: "Don Mariano Cui St, Cebu City, Cebu",
            latlng: {
                lat: 10.3098146,
                lng: 123.8872474
            },
            name: "QUETUA,ROWENA",
            specialty: "PEDIATRICS"
        },
        remarks: '',
        status: ''
    },
    {
        id: 24,
        userid: 2,
        merchantid: 225,
        address: "Don Mariano Cui St, Cebu City, Cebu",
        type: "COVERAGE",
        cost: 500.00,
        description: 'Product presentation',
        transaction_date: "2017-02-09T09:35:20",
        travel_time_in_minutes: 40,
        average_travel_time_in_minutes: 55,
        start_point_latlng: {
            lat: 10.306362,
            lng: 123.8995343
        },
        end_point_latlng: {
            lat: 10.3103062,
            lng: 123.8905109
        },
        icon: angular.merge({}, coverageIcon, {color: '#95a5a6'}),
        merchant: {
            address: "Don Mariano Cui St, Cebu City, Cebu",
            latlng: {
                lat: 10.3103062,
                lng: 123.8905109
            },
            name: "VALENZUELA,ELENA",
            specialty: "PEDIATRICS"
        },
        remarks: '',
        status: ''
    },
    {
        id: 25,
        userid: 2,
        merchantid: 226,
        address: "Osmeña Blvd, Cebu City,",
        type: "COVERAGE",
        cost: 850.50,
        description: 'Client visit and orientation',
        transaction_date: "2017-02-08T13:00:15",
        travel_time_in_minutes: 75,
        average_travel_time_in_minutes: 60,
        start_point_latlng: {
            lat: 10.306362,
            lng: 123.8995343
        },
        end_point_latlng: {
            lat: 10.3144225,
            lng: 123.8920168
        },
        icon: angular.merge({}, coverageIcon, {color: '#2ecc71'}),
        merchant: {
            address: "Osmeña Blvd, Cebu City,",
            latlng: {
                lat: 10.3144225,
                lng: 123.8920168
            },
            name: "GUICO,ELSA",
            specialty: "PEDIATRICS"
        },
        remarks: 'OK',
        status: 'CLEARED'
    },
    {
        id: 29,
        userid: 2,
        merchantid: null,
        address: "Fuente, Cebu City, Cebu",
        type: "1SS",
        cost: 2000,
        description: 'client meeting',
        transaction_date: "2017-02-10T10:05:00",
        travel_time_in_minutes: 40,
        average_travel_time_in_minutes: 45,
        start_point_latlng: null,
        end_point_latlng: {
            lat: 10.3101402,
            lng: 123.8923542
        },
        icon: {
            markerIcon: 'atm',
            color: '#2ecc71',
            icon: 'local_atm'
        },
        merchant: null,
        remarks: 'OK',
        status: 'CLEARED'
    },
];

    var dateMoment;

angular.module('demoApp.fraud')

    .constant('COVERAGE_DATA', coverageSampleData.map(function(item){
        dateMoment = moment(item.transaction_date);
        item.transaction_date_formatted = dateMoment.format('dddd, MMMM DD, YYYY h:mm:ss A');
        return item;
    }))

;

}());
(function () {
    'use strict';

    angular
        .module('demoApp.admin', []);

}());

(function(){
'use strict';

angular.module('demoApp.admin')
    .controller('adminPanelController', ['$rootScope', '$scope', 'boundariesService', 'branchService', 'userTerritoriesService', '$timeout', 'gmapServices', '$q', 'alertServices', 'placesService', '$mdSidenav', 'mapToolsService', '$mdToast', adminPanelController]);

    function adminPanelController ($rootScope, $scope, boundariesService, branchService, userTerritoriesService, $timeout, gmapServices, $q, alertServices, placesService, $mdSidenav, mapToolsService, $mdToast) {
        var vm = this;

        var polygonObj,
            adminInfowindow;
        ;

        var selectedTypes = [],
            foundTypeIndex,
            isSelected;

        var promises = [];
        var aborts = {};

        var currentSelected = {
            type: '', // boundary/territory
            id: '',
            typeid: ''
        };

        vm.boundaries = [];
        vm.territories = [];
        vm.showTerritoriesPanel = false;
        vm.showPoiPanel = false;

        vm.expandCallback = expandCallback;
        vm.showBoundary = showBoundary;
        vm.showTerritory = showTerritory;
        vm.toggleType = toggleType;
        vm.uploadBranchData = uploadBranchData;
        vm.uploadSalesData = uploadSalesData;

        initialize();

        function initialize () {
            adminInfowindow = gmapServices.createInfoWindow('');

            boundariesService.loadBoundaries()
                .then(function (list) {
                    vm.boundaries = angular.copy(list);
                }, function (error) {
                    console.log('failed to load: ', error);
                });

            var rawTypes = placesService.getPlaceTypes().map(function (type) {
                foundTypeIndex = placesService.defaultPlaceTypes.indexOf(type);
                isSelected = false;

                // initially select default place type
                if (foundTypeIndex !== -1) {
                    selectedTypes.push(type);
                    isSelected = true;
                }

                return {
                    name: type,
                    model: isSelected
                }
            });

            vm.placeTypes = _.groupBy(rawTypes, function (item, index) {
                return index % 2;
            });

            $scope.$watch(function(){
                return vm.showTerritoriesPanel;
            }, function (newValue, oldValue){
                if (newValue === oldValue) return;

                if (newValue) {
                    vm.showPoiPanel = true;
                } else {
                    //vm.loadPois = false;
                    //vm.showPoiPanel = false;
                }

                clear();

                if (!newValue) $mdSidenav('territoryInfoPanelSidenav').close();
            });

            $rootScope.$watch('currentUser', function (newValue, oldValue) {
                if (!newValue) return;

                userTerritoriesService.getTerritories()
                    .then(function (territories) {
                        vm.territories = _.uniq(territories, true, function (item) {
                            return item.territoryid;
                        });
                    });
            });

            $scope.$watch(function(){
                return vm.loadPois;
            }, function(newValue, oldValue){
                if (newValue === oldValue) return;

                if (newValue) {
                    placesService.showVisiblePOIs();
                    return;
                }

                placesService.hidePOIs();
            });
        }

        function showPolygon(latLngArray, isTerritory) {
            //console.log('showPolygon: ',latLngArray);
            if (!latLngArray.length) {
                alertServices.showError('Cannot load polygon, data error.');
                return;
            }

            var color = isTerritory ? '#3f51b5' : '#ff0000';

            if (polygonObj) {
                polygonObj.setOptions({
                    fillColor: color,
                    strokeColor: color,
                    paths: latLngArray
                });
            } else {
                polygonObj = gmapServices.createPolygon(latLngArray, color);
            }
        }

        /*
        * Show POI by type
        */

        function toggleType(type) {
            var arr = vm.placeTypes['0'].concat(vm.placeTypes['1']);
            var val = _.findWhere(arr, {name: type});

            var index = selectedTypes.indexOf(val.name);

            if (val.model && index === -1) {
                selectedTypes.push(val.name)
            } else if (index !== -1) {
                selectedTypes.splice(index, 1);
            }

            if (!currentSelected.id || !vm.loadPois) return;

            if (currentSelected.type == 'territory' && $rootScope.selectedTerritory) {
                placesService.loadPOIs($rootScope.selectedTerritory.territoryid, selectedTypes)
                    .then(function (response) {
                        console.log('loadPOIs response',response);
                        placesService.showPOIs(response);
                        $rootScope.selectedTerritory.places = response;
                    });
            } else if (currentSelected.type == 'boundary' && currentSelected.typeid >= 6) { // show pois for city and brgy level
                placesService.loadPOIsWithinBoundary(currentSelected.id, selectedTypes)
                    .then(function (response) {
                        placesService.showPOIs(response, adminInfowindow);
                    });
            }
        }

        function showBoundary(boundary, isParent) {
            clear();

            currentSelected = {
                type: 'boundary',
                id: boundary.id,
                typeid: boundary.typeid
            };

            var item = boundariesService.getRestangularObj(boundary.id);

            for (var k in aborts) if (aborts[k]) aborts[k].resolve();

            aborts = {
                detail: $q.defer(),
                branches: $q.defer()
            };

            if (boundary.typeid == 6) {
                $('v-pane#' + boundary.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'block'});
            } else {
                $('md-list-item#' + item.id.toString() + ' md-progress-circular').show();
            }

            // show poi selection for city and barangay
            if (boundary.typeid >= 6) {
                $timeout(function () {
                    vm.showPoiPanel = true;
                    vm.loadPois = true;
                }, 500);
            }

            promises.push(
                item.withHttpConfig({timeout: aborts.detail.promise})
                    .get()
                    .then(function (response) {
                        var resp = response.plain();
                        showPolygon(resp.geometry);
                        gmapServices.fitToBoundsByPolygon(polygonObj);
                    })
            );

            // load branches
            promises.push(
                item.withHttpConfig({timeout: aborts.branches.promise})
                    .getList('branches')
                    .then(function (response) {
                        var resp = response.plain();

                        if (!resp.length) {
                            alertServices.showBottomLeftToast(boundary.name.capitalize() + ' doesnt have branch yet.');
                            return;
                        }

                        branchService.loadMarkers(resp.map(function (item) {
                            return item.branch;
                        }), null, adminInfowindow);
                    })
                    .finally(function () {
                        $timeout(function () {
                            if (boundary.typeid == 6) $('v-pane#' + boundary.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'none'});
                            else $('md-list-item#' + item.id.toString() + ' md-progress-circular').hide();
                        }, 500);
                    })
            );

            // load places
            if (vm.loadPois && !isParent) {
                promises.push(
                    placesService.loadPOIsWithinBoundary(boundary.id, selectedTypes)
                        .then(function (response) {
                            placesService.showPOIs(response, adminInfowindow);
                        })
                );
            }

            //$q.all(promises)
            //    .finally(function(){
            //        $timeout(function () {
            //            if (boundary.typeid == 6) $('v-pane#' + boundary.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'none'});
            //            else $('md-list-item#' + item.id.toString() + ' md-progress-circular').hide();
            //        }, 500);
            //    });
        }

        function boundaryAfterExpand(item) {
            if (item.typeid == 6) {
                showBoundary(item, true);
            } else {
                $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'none'});
            }
        }

        function expandCallback(item, event) {
            event.stopPropagation();

            if (item.isExpanded === false) return;

            vm.showPoiPanel = false;
            vm.loadPois = false;

            //if (item.typeid < 7) {
            if (item.typeid < 7) {
                if (item.hasOwnProperty('children') && item.children.length) {
                    boundaryAfterExpand(item);
                    return;
                }

                $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'block'});

                item.children = [];

                $('v-pane#' + item.id.toString() + ' v-pane-content v-accordion').children().html('');

                boundariesService.loadBoundaries(item.id)
                    .then(function (list) {
                        if (list.length) item.children = angular.copy(list);
                    }, function (error) { console.log('failed to load: ', error); })
                    .finally(function () {
                        boundaryAfterExpand(item);
                    });

                return;
            }

            showBoundary(item);

            return;
        }

        function clear () {
            $rootScope.$broadcast('clear-compare-branches');
            branchService.hideMarkers();
            placesService.hidePOIs();
            if (polygonObj) {
                polygonObj.setMap(null);
                polygonObj = null;
            }
            $mdToast.hide();
            mapToolsService.clearMeasurementLines();
        }

        function showTerritory (item) {
            clear();

            console.log('showTerritory: ',item);

            if (!vm.loadPois) vm.loadPois = true;

            currentSelected = {
                type: 'territory',
                id: 'item.id',
                typeid: ''
            };

            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').show();

            $rootScope.selectedTerritory = item;

            showPolygon(item.territory.geom, true);
            gmapServices.fitToBoundsByPolygon(polygonObj);

            var promises = [];

            // load places
            if (vm.loadPois) {
                promises.push(
                    placesService.loadPOIs(item.territoryid, selectedTypes)
                        .then(function (response) {
                            placesService.showPOIs(response, adminInfowindow);
                            $rootScope.selectedTerritory.places = response;
                        })
                );
            }

            promises.push(
                userTerritoriesService.getTerritoryBranches(item.territoryid)
                    .then(function (response) {
                        //console.log('territory branches: ',response);
                        if (!response.length) {
                            alertServices.showBottomLeftToast('This territory doesnt have branch yet.');
                        } else {
                            $rootScope.selectedTerritory.branches = response;
                            branchService.loadMarkers(response, null, adminInfowindow);
                        }

                        $timeout(function () {
                            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
                        }, 500);

                        $mdSidenav('territoryInfoPanelSidenav').open();
                        $rootScope.$broadcast('territory_selected', $rootScope.selectedTerritory);
                    })
            );
        }

        function uploadBranchData(file, errFiles, event) {
            event.stopPropagation();

            if (!file || errFiles.length) {
                alertServices.showError('File is invalid.\nAccepts excel file only.\n .xlsx, .xls');
                return;
            }

            alertServices.showInfo('Uploading, Please wait...');

            branchService.uploadBranchData(file)
                .then(function (response) {
                    console.log('successfully uploaded branch data: ', response);
                    alertServices.showInfo('Branches uploaded.', true);
                }, function (error) {
                    console.log('error on uploading data: ', error);
                });
        }

        function uploadSalesData(file, errFiles, event) {
            event.stopPropagation();

            if (!file || errFiles.length) {
                alertServices.showError('File is invalid.\nAccepts excel file only.\n .xlsx, .xls');
                return;
            }

            alertServices.showInfo('Uploading, Please wait...');

            branchService.uploadBranchSellOutData(file)
                .then(function (response) {
                    console.log('successfully uploaded sales data: ', response);
                    alertServices.showInfo('Sellouts uploaded.', true);
                }, function (error) {
                    console.log('error on uploading data: ', error);
                });
        }

    }
}());
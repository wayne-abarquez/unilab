(function () {
    'use strict';

    angular
        .module('demoApp.sales', [])

        .constant('SALES_TRANSACTION_TYPES', ['CLIENT VISIT', 'GAS', 'FLIGHT'])
        .constant('BRANCH_TYPES', ['MDC', 'LKA', 'GT'])

    ;

}());

(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('territoryInfoPanelController', ['$rootScope', 'branchService', 'placesService', '$mdSidenav', territoryInfoPanelController]);

    function territoryInfoPanelController ($rootScope, branchService, placesService, $mdSidenav) {
        var vm = this;

        vm.showPOIByType = showPOIByType;
        vm.toggleBranches = toggleBranches;
        vm.close = close;

        initialize();

        function initialize () {
            $rootScope.$on('territory_selected', function (e, data) {
                vm.territory = angular.copy(data);

                if (!vm.territory.places) return;

                var allPlaces = [];
                for (var k in vm.territory.places) {
                    vm.territory.places[k].forEach(function (item) {
                        allPlaces.push(item);
                    });
                }
                vm.territory.places['all'] = allPlaces;
            });

            $rootScope.$on('close-territory-info-panel', function(){
               close();
            });
        }

        function showPOIByType (type) {
            placesService.showPOIByType(type);
        }

        function toggleBranches () {
            branchService.toggleMarkers();
        }

        function close () {
            //$rootScope.showGRDPPanel = false;

            $mdSidenav('territoryInfoPanelSidenav')
                .close()
                .then(function () {
                    $rootScope.showTerritoryDetailBtn = true;
                });
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp.sales')
        .factory('Territory', ['Restangular', Territory]);

    function Territory(Restangular) {
        var myModel = Restangular.all('territories');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'territories');
            }
        };

        Restangular.extendModel('territories', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .factory('salesTransactionService', ['SalesTransaction', '$q', salesTransactionService]);

    function salesTransactionService (SalesTransaction, $q) {
        var service = {};

        service.saveTransaction = saveTransaction;

        function saveTransaction(data, id) {
            var dfd = $q.defer();

            if (id) { // update
                var restObj = SalesTransaction.cast(id);
                restObj.customPUT(data)
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            } else { // insert
                SalesTransaction.post(data)
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.sales')
        .factory('SalesTransaction', ['Restangular', SalesTransaction]);

    function SalesTransaction(Restangular) {
        var myModel = Restangular.all('salestransactions');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'salestransactions');
            }
        };

        Restangular.extendModel('salestransactions', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('salesPanelController', ['$q', '$scope', '$rootScope', 'userTerritoriesService', 'gmapServices', 'branchService', '$mdSidenav', 'placesService', '$timeout', 'alertServices', salesPanelController]);

    function salesPanelController ($q, $scope, $rootScope, userTerritoriesService, gmapServices, branchService, $mdSidenav, placesService, $timeout, alertServices) {
        var vm = this;

        var polygonTerritory;

        var foundTypeIndex,
            isSelected;

        var selectedTypes = [];

        vm.territories = [];

        vm.filter = {
            q: ''
        };

        vm.toggleToolbarPanel = toggleToolbarPanel;
        vm.showTerritoryDetails = showTerritoryDetails;
        vm.toggleType = toggleType;

        initialize();

        function initialize () {
            $rootScope.$watch('currentUser', function (newValue) {
                if (!newValue) return;

                userTerritoriesService.getTerritories()
                    .then(function (territories) {
                        vm.territories = angular.copy(territories);
                    });
            });

            var rawTypes = placesService.getPlaceTypes().map(function (type) {
                foundTypeIndex = placesService.defaultPlaceTypes.indexOf(type);
                isSelected = false;

                // initially select default place type
                if (foundTypeIndex !== -1) {
                    selectedTypes.push(type);
                    isSelected = true;
                }

                return {
                    name: type,
                    model: isSelected
                }
            });

            vm.placeTypes = _.groupBy(rawTypes, function(item, index){
               return index % 2;
            });

            $scope.$watch(function () {
                return vm.loadPois;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;

                if (newValue) {
                    placesService.showVisiblePOIs();
                    return;
                }

                placesService.hidePOIs();
            });
        }

        function toggleToolbarPanel () {
            vm.filter.q = '';
            vm.showFilterPanel = !vm.showFilterPanel;
        }

        function showPolygonTerritory(latLngArray) {
            if (!latLngArray.length) {
                alertServices.showError('Cannot load polygon, data error.');
                return;
            }

            if (polygonTerritory) {
                polygonTerritory.setPath(latLngArray);
                return;
            }

            polygonTerritory = gmapServices.createPolygon(latLngArray, '#3f51b5');
            polygonTerritory.setVisible(false);
        }

        function toggleType(type) {
            var arr = vm.placeTypes['0'].concat(vm.placeTypes['1']);
            var val = _.findWhere(arr, {name: type});

            var index = selectedTypes.indexOf(val.name);

            if (val.model && index === -1) {
                selectedTypes.push(val.name)
            } else if (index !== -1) {
                selectedTypes.splice(index, 1);
            }
        }

        function showTerritoryDetails (item) {
            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').show();

            $rootScope.selectedTerritory = item;

            branchService.hideMarkers();
            placesService.hidePOIs();

            showPolygonTerritory(item.territory.geom);

            gmapServices.setZoomIfGreater(12);
            gmapServices.panToPolygon(polygonTerritory);

            var promises = [];

            // load places
            if (vm.loadPois) {
                console.log('selected place types: ', selectedTypes);
                promises.push(
                    placesService.loadPOIs(item.territoryid, selectedTypes)
                        .then(function (response) {
                            placesService.showPOIs(response);
                            $rootScope.selectedTerritory.places = response;
                        })
                );
            }

            promises.push(
                userTerritoriesService.getTerritoryBranches(item.territoryid)
                    .then(function (response) {
                        $rootScope.selectedTerritory.branches = response;

                        if (!response.length) {
                            alertServices.showBottomLeftToast('This territory doesnt have branch yet.');
                        } else {
                            branchService.loadMarkers(response);
                        }

                        $timeout(function () {
                            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
                        }, 500);

                        $mdSidenav('territoryInfoPanelSidenav').open();
                        $rootScope.$broadcast('territory_selected', $rootScope.selectedTerritory);
                    })
            );

            //$q.all([promises])
            //    .finally(function(){
            //        $timeout(function () {
            //            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
            //        }, 1000);
            //    });
        }


    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('salesPageController', ['$rootScope', 'gmapServices', 'modalServices', salesPageController]);

    function salesPageController ($rootScope, gmapServices, modalServices) {
        var vm = this;

        initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');

            $rootScope.$on('search-address-return-result', function (e, params) {
                if ($rootScope.hasOpenedModal) return;

                modalServices.showNewTransactionForm(e, params)
                    .finally(function () {
                        $rootScope.$broadcast('clear-search-address-bar');
                    });
            });
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('newTransactionController', ['param', '$scope', 'SALES_TRANSACTION_TYPES', 'MARKER_BASE_URL', 'modalServices', 'alertServices', 'gmapServices', 'formHelperService', '$timeout', 'salesTransactionService', newTransactionController]);

    function newTransactionController (param, $scope, SALES_TRANSACTION_TYPES, MARKER_BASE_URL, modalServices, alertServices, gmapServices, formHelperService, $timeout, salesTransactionService) {
        var vm = this;

        var result;
        var autocompleteResult

        var markers = {
          start: {
              marker: null,
              icon: MARKER_BASE_URL + 'start.png',
              dragendListener: null
          },
          end: {
              marker: null,
              icon: MARKER_BASE_URL + 'end.png',
              dragendListener: null
          }
        };

        var autocompletes = {
            start: {
                autocomplete: null,
                id: 'filter-starting-address-input',
                callback : null
            },
            end: {
                autocomplete: null,
                id: 'filter-destination-address-input',
                callback: null
            }
        };

        var directionsService,
            directionsDisplay;

        vm.transactionTypes = SALES_TRANSACTION_TYPES;
        vm.maxDate = new Date();

        vm.form = {};
        vm.transaction = {};

        vm.save = save;
        vm.close = close;

        initialize();

        function initialize () {
            if (param && param.result) {
                result = angular.copy(param.result);

                gmapServices.setZoomIfGreater(14);

                alertServices.showBottomLeftToast('Drag marker to point exact location.', 10000);

                vm.transaction.address = result.formatted_address;
                vm.transaction.end_point_address = result.formatted_address;
                createDestinationPointMarker(result.geometry.location);
            }

            directionsService = new google.maps.DirectionsService;
            directionsDisplay = new google.maps.DirectionsRenderer({draggable: true});
            directionsDisplay.setMap(gmapServices.map);

            $timeout(function(){
                initializeAutocompletes();
            }, 1000);

            //$rootScope.$on('search-address-return-result', function (e, params) {
            //    vm.transaction.address = params.result.formatted_address;
            //    setPlotMarkerLocation(params.result.geometry.location);
            //});

            $scope.$watch(function(){
                return vm.transaction.start_point_latlng;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;

               if (newValue && vm.transaction.end_point_latlng) {
                   calculateAndDisplayRoute(newValue, vm.transaction.end_point_latlng);
               }
            });

            $scope.$watch(function () {
                return vm.transaction.end_point_latlng;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;

                if (newValue && vm.transaction.start_point_latlng) {
                    calculateAndDisplayRoute(vm.transaction.start_point_latlng, newValue);
                }
            });

            $scope.$on('$destroy', function () {
                cleanUp();
            });
        }

        function cleanUp() {
            for (var k in markers) {
                if (markers[k].marker && markers[k].marker.getMap()) {
                    markers[k].marker.setMap(null);
                    markers[k].marker = null;
                }
                if (markers[k].dragendListener) {
                    gmapServices.removeListener(markers[k].dragendListener);
                }
            }
            directionsDisplay.setMap(null);
            directionsService = null;
            directionsDisplay = null;
        }

        function calculateAndDisplayRoute(originLatlng, destinationLatLng) {
            directionsService.route({
                origin: originLatlng,
                destination: destinationLatLng,
                travelMode: 'DRIVING'
            }, function (response, status) {
                console.log('calculateAndDisplayRoute response: ', response);
                if (status === 'OK') {
                    directionsDisplay.setDirections(response);
                } else {
                    alertServices.showError('Directions request failed due to ' + status);
                }
            });
        }

        function placeChangeCallback(autocompleteObj) {
            var place = autocompleteObj.getPlace();

            if (!place.geometry) {
                alertServices.showInfo("Address not found.");
                return;
            }

            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }

            return place;
        }

        function createStartPointMarker (latlng) {
            markers.start.marker = gmapServices.initMarker(latlng, markers.start.icon, {draggable: true});
            vm.transaction.start_point_latlng = latlng.toJSON();

            markers.start.dragendListener = gmapServices.addListener(markers.start.marker, 'dragend', function (e) {
                vm.transaction.start_point_latlng = e.latLng.toJSON();
                // reverse geocode latlng
                gmapServices.reverseGeocode(e.latLng)
                    .then(function (result) {
                        if (result.length) vm.transaction.start_point_address = result[0].formatted_address;
                    });
            });
            return markers.start.marker;
        }

        function createDestinationPointMarker(latlng) {
            markers.end.marker = gmapServices.initMarker(latlng, markers.end.icon, {draggable: true});
            vm.transaction.end_point_latlng = latlng.toJSON();

            markers.end.dragendListener = gmapServices.addListener(markers.end.marker, 'dragend', function (e) {
                vm.transaction.end_point_latlng = e.latLng.toJSON();
                // reverse geocode latlng
                gmapServices.reverseGeocode(e.latLng)
                    .then(function (result) {
                        if (result.length) {
                            vm.transaction.end_point_address = result[0].formatted_address;
                            vm.transaction.address = result[0].formatted_address;
                        }
                    });
            });
            return markers.end.marker;
        }

        function setPlotMarkerLocation(latlng, markerInstance) {
            gmapServices.panTo(latlng);

            if (markerInstance && markerInstance.getMap()) {
                markerInstance.setOptions({
                    visible: true,
                    animation: google.maps.Animation.DROP,
                    position: latlng
                });
            }
        }

        function initializeAutocompletes () {
            autocompletes.start.callback = function () {
                autocompleteResult = placeChangeCallback(autocompletes.start.autocomplete);
                if (!markers.start.marker) createStartPointMarker(autocompleteResult.geometry.location);
                else setPlotMarkerLocation(autocompleteResult.geometry.location, markers.start.marker);
            };

            autocompletes.end.callback = function () {
                autocompleteResult = placeChangeCallback(autocompletes.end.autocomplete);

                if (!markers.end.marker) createDestinationPointMarker(autocompleteResult.geometry.location);
                else setPlotMarkerLocation(autocompleteResult.geometry.location, markers.end.marker);

                $scope.$apply(function () {
                    vm.transaction.address = angular.copy(autocompleteResult.formatted_address);
                });
            };

            for (var k in autocompletes) {
                autocompletes[k].autocomplete = gmapServices.initializeAutocomplete(autocompletes[k].id, {
                    componentRestrictions: {country: 'ph'}
                });
                autocompletes[k].autocomplete.addListener('place_changed', autocompletes[k].callback);
            }
        }

        function getFormData() {
            var date = vm.transaction.transaction_date.toISOString();

            var formData = angular.copy(vm.transaction);
            formData.transaction_date = date;

            formData.start_point_latlng = markers.start.marker.getPosition().toJSON();
            formData.end_point_latlng = markers.end.marker.getPosition().toJSON();

            return formData;
        }

        function save() {
            if (!vm.form.$valid) {
                formHelperService.showFormErrors(vm.form.$error);
                return;
            }

            if (!markers.start.marker) {
                vm.transaction.start_point_address = '';
                return;
            } else if (!markers.end.marker) {
                vm.transaction.end_point_address = '';
                return;
            }

            console.log('save transaction: ', vm.transaction);
            var formData = getFormData();
            console.log('formData: ', formData);

            // process send to backend
            salesTransactionService.saveTransaction(formData)
                .then(function (response) {
                    console.log('save sales transaction: ',response);
                    alertServices.showSuccess('Transaction saved.');
                    modalServices.hideResolveModal(response);
                }, function (error) {
                    console.log('save sales transaction error: ', error);
                    // show errors
                    alertServices.showError(formHelperService.getFormattedErrors(error.data));
                })
                .finally(function () {
                    // hide spinner
                });
        }

        function close () {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('newBranchController', ['param', '$scope', '$rootScope', 'BRANCH_TYPES', 'MARKER_BASE_URL', 'modalServices', 'alertServices', 'gmapServices', 'formHelperService', '$timeout', 'branchService', newBranchController]);

    function newBranchController (param, $scope, $rootScope, BRANCH_TYPES, MARKER_BASE_URL, modalServices, alertServices, gmapServices, formHelperService, $timeout, branchService) {
        var vm = this;

        var result;

        var plotMarker,
            markerUrl = MARKER_BASE_URL + 'default-marker.png',
            dragendListener;

        vm.branchTypes = BRANCH_TYPES;
        vm.maxDate = new Date();

        vm.form = {};
        vm.branch = {};

        vm.save = save;
        vm.setLocation = setLocation;
        vm.close = close;

        initialize();

        function initialize () {
            if (param && param.result) {
                result = angular.copy(param.result);

                plotMarker = createPlotMarker(result.geometry.location);
                gmapServices.setZoomIfGreater(14);

                alertServices.showBottomLeftToast('Drag marker to point exact location.', 10000);

                vm.branch.address = result.formatted_address;
                vm.branch.latlng = result.geometry.location.toJSON();
            }

            $rootScope.$on('search-address-return-result', function (e, params) {
                vm.branch.address = params.result.formatted_address;
                setPlotMarkerLocation(params.result.geometry.location);
            });

            $scope.$on('$destroy', function () {
                cleanUp();
            });
        }

        function cleanUp () {
            if (dragendListener) {
                gmapServices.removeListener(dragendListener);
            }

            if (plotMarker && plotMarker.getMap()) {
                plotMarker.setMap(null);
                plotMarker = null;
            }
        }

        function createPlotMarker (latlng) {
            var marker = gmapServices.initMarker(latlng, markerUrl, {draggable: true});

            dragendListener = gmapServices.addListener(marker, 'dragend', function(e) {
                // reverse geocode latlng
                gmapServices.reverseGeocode(e.latLng)
                    .then(function(result){
                        if (result.length) vm.branch.address = result[0].formatted_address;
                    });
            });

            return marker;
        }

        function setPlotMarkerLocation(latlng) {
            gmapServices.panTo(latlng);

            if (plotMarker && plotMarker.getMap()) {
                plotMarker.setOptions({
                    visible: true,
                    animation: google.maps.Animation.DROP,
                    position: latlng
                });
            }
        }

        function getFormData () {
            var date = formHelperService.getDateFormatted(vm.branch.operation_started_date);

            var formData = angular.copy(vm.branch);
            formData.operation_started_date = date;
            formData.latlng = plotMarker.getPosition().toJSON();

            return formData;
        }

        function save () {
            if (!vm.form.$valid) {
                formHelperService.showFormErrors(vm.form.$error);
                return;
            }

            //console.log('branch: ', vm.branch);

            var formData = getFormData();

            // process send to backend
            //console.log('formData: ', formData);

            branchService.saveBranch(formData)
                .then(function(response){
                    //console.log('save branch: ',response);
                    alertServices.showSuccess('New Branch saved.');
                    modalServices.hideResolveModal(response);
                },function(error){
                    console.log('save branch error: ', error);
                    // show errors
                    alertServices.showError(formHelperService.getFormattedErrors(error.data));
                })
                .finally(function(){
                    // hide spinner
                });
        }

        function setLocation () {
            $('#index-container .md-dialog-container').hide();
            plotMarker.setVisible(false);
            gmapServices.setMapCursorCrosshair();

            var mapClickListener = gmapServices.addMapListener('click', function(e){
                $('#index-container .md-dialog-container').show();
                gmapServices.setMapCursorDefault();
                gmapServices.removeListener(mapClickListener);

                $timeout(function(){
                    setPlotMarkerLocation(e.latLng);
                }, 500);
            });
        }

        function close () {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('compareBranchesTableController', ['$rootScope', '$scope', 'branchService', compareBranchesTableController]);

    function compareBranchesTableController ($rootScope, $scope, branchService) {
        var vm = this;

        vm.branchCompareList = [];
        $rootScope.showBranchCompareTable = false;
        vm.currentIndex = 0;

        vm.removeBranch = removeBranch;
        vm.hoverIn = hoverIn;
        vm.hoverOut = hoverOut;
        vm.close = close;

        initialize();

        function initialize() {

            $scope.$watchCollection(function () {
                return vm.branchCompareList;
            }, function (newCollection) {
                if (newCollection.length) {
                    $rootScope.showBranchCompareTable = true;
                    $('#show-compare-branches-btn').show();
                    return;
                }

                $rootScope.showBranchCompareTable = false;
                $('#show-compare-branches-btn').hide();
                branchService.resetMarkersColor();
            });

            $rootScope.$on('new-compare-branch', function (e, branch) {

                if (_.findWhere(vm.branchCompareList, {id: branch.id})) return;

                vm.branchCompareList.push(transform(branch));

                compileList();
                highlightComparedBranches();
            });

            $rootScope.$watch('showBranchCompareTable', function (newValue, oldValue) {
                if (newValue === oldValue) return;

                if (newValue) highlightComparedBranches();
                else branchService.resetMarkersColor();
            });

            $(document).on('mouseover', '#compare-branch-table-container table.md-table tr:nth-child(2) td', function () {
                var index = $(this).index();
                $("#compare-branch-table-container table.md-table tr").find("td:nth-child(" + (index + 1) + ")").addClass("current-col");
            });

            $(document).on('mouseout', '#compare-branch-table-container table.md-table tr:nth-child(2) td', function () {
                var index = $(this).index();
                $("#compare-branch-table-container table.md-table tr").find("td:nth-child(" + (index + 1) + ")").removeClass("current-col");
            });
        }

        function highlightComparedBranches () {
            var ids = _.pluck(vm.branchCompareList, 'id');
            branchService.highlightMarkers(ids);
        }

        function transform (obj) {
            var result = {};

            result['id'] = obj.id;
            result['name'] = obj.name;

            obj.products.forEach(function(prod){
               result[prod.product.name] = prod.product.name;
            });

            return result;
        }

        function indexByAttribute(collection) {
            return collection.reduce(function (result, item) {

                angular.forEach(item, function (value, index) {
                    result[index] = result[index] || [];
                    result[index].push(value);
                });

                return result;
            }, {});
        }

        function compileList () {
            vm.list = indexByAttribute(vm.branchCompareList);
        }

        function removeBranch(branchId) {
            var index = _.findIndex(vm.branchCompareList, {id: branchId});

            if (index > -1) {
                branchService.unHighlightMarker(branchId);

                vm.branchCompareList.splice(index, 1);

                compileList();

                if($scope.$$phase) return;

                $scope.$apply(function(){
                    return vm.list;
                });
            }
        }

        function hoverIn (branchId) {
            branchService.animateMarker(branchId);
        }

        function hoverOut (branchId) {
            branchService.clearAnimationMarker(branchId);
        }

        function close () {
            $rootScope.showBranchCompareTable = false;
        }



    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.home', [
            'vAccordion'
        ]);

}());

(function(){
'use strict';

angular.module('demoApp.home')
    .factory('userTerritoriesService', ['$q', 'userSessionService', 'Territory', userTerritoriesService]);

    function userTerritoriesService ($q, userSessionService, Territory) {
        var service = {};

        var abort;

        service.getTerritories = getTerritories;
        service.getTerritoryBranches = getTerritoryBranches;

        function getTerritories () {
            var dfd = $q.defer();

            var currentUser = userSessionService.getUserInfo(true);

            currentUser.getList('territories')
                .then(function(response){
                    dfd.resolve(response.plain());
                }, function(error){
                    console.log('get user territories error: ', error);
                    dfd.reject(error);
                })

            return dfd.promise;
        }

        function getTerritoryBranches (territoryId) {
           var dfd = $q.defer();

            if (abort) abort.resolve();

            abort = $q.defer();

            Territory.cast(territoryId)
               .withHttpConfig({timeout: abort})
               .getList('branches')
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        console.log('error: ', error);
                        dfd.reject(error);
                    });

            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('userSessionService', ['User', 'localStorageService', '$q', '$rootScope', userSessionService]);

    function userSessionService (User, localStorageService, $q, $rootScope) {
        var service = {};

        // user details
        var USER = 'USER';

        service.userLogin = userLogin;
        service.userLogout = userLogout;
        service.getUserInfo = getUserInfo;

        function userLogin () {
            if (!localStorageService.isSupported) return;

            var dfd = $q.defer();
            var currentUser = getUserInfo();

            if (currentUser) {
                dfd.resolve(currentUser);
            } else {
                User.customGET('current_user')
                    .then(function (response) {
                        localStorageService.set(USER, response.plain());
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function userLogout () {
            if (!localStorageService.isSupported) return;

            // clear all data on local storage on logout
            localStorageService.clearAll();
        }

        function getUserInfo (isRestangular) {
            if (!localStorageService.isSupported) return;

            var userObj = localStorageService.get(USER);

            return isRestangular ?
                            User.cast(userObj.id)
                            : userObj;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .factory('User', ['Restangular', User]);

    function User(Restangular) {
        var myModel = Restangular.all('users');

        var resource = {
            cast: function (userId) {
                return Restangular.restangularizeElement(null, {id: userId}, 'users');
            }
        };

        Restangular.extendModel('users', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('indexController', ['gmapServices', '$rootScope', '$mdSidenav', 'modalServices', '$injector', indexController]);

    function indexController (gmapServices, $rootScope, $mdSidenav, modalServices, $injector) {
        var vm = this;

        vm.lastSideNavOpenId = '';

        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        initialize();

        function initialize() {
            gmapServices.createMap('map-canvas');

            $rootScope.$on('search-address-return-result', function (e, params) {
               if ($rootScope.hasOpenedModal) return;

               modalServices.showMapPlotOptions(e)
                   .then(function(selectedOption){
                       $injector.get('modalServices')[selectedOption.action](e, params)
                           .finally(function(){
                               $rootScope.$broadcast('clear-search-address-bar');
                           });
                   });
            });
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }
                $mdSidenav(navID).toggle();
                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('gmapController', [gmapController]);

    function gmapController() {

        //function showSolarDetailInfowindow (_solar) {
        //    if(!(_solar && _solar.id)) return;
        //
        //    solarGmapServices.hideSolarMarkers();
        //
        //    var defered = modalServices.showUpdateSolar(_solar, vm, event);
        //    defered.then(function (response) {
        //        console.log('modalServices.showUpdateSolar response:');
        //        console.log(response);
        //
        //            if (!response) return;
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //            if($rootScope.selectedSolar && response) {
        //                $rootScope.selectedSolar.coordinates = response.coordinates;
        //            }
        //        }, function (errorResponse) {
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //
        //            console.log('show update solar detail failed');
        //            console.log(errorResponse);
        //        });
        //}
        //
        //
        //function showMarkers () {
        //    solarGmapServices.showSolarMarkers();
        //    solarGmapServices.resetZoom();
        //}

        //function hideMarkers () {
        //    console.log('called from event : modal-opened');
        //    console.log('gmapcontroller hide markers');
        //    solarGmapServices.hideSolarMarkers();
        //    // Hide Solar List Table
        //    $rootScope.showSolarList = false;
        //}
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('branchService', ['MARKER_BASE_URL', '$q', 'Branch', 'gmapServices', '$rootScope', branchService]);

    function branchService (MARKER_BASE_URL, $q, Branch, gmapServices, $rootScope) {
        var service = {};

        var branchMarkers = [],
            branchInfowindow;

        var branchIcons = {
            'mdc': 'branch-red.png',
            'lka': 'branch-green.png',
            'gt': 'branch-blue.png'
        };

        var iconBaseUrl = MARKER_BASE_URL;
        var unhighlightIcon = 'branch-default.png';

        service.saveBranch = saveBranch;
        service.loadMarkers = loadMarkers;
        service.showMarkers = showMarkers;
        service.hideMarkers = hideMarkers;
        service.toggleMarkers = toggle;
        service.dismissInfowindow = dismissInfowindow;
        service.getBranchById = getBranchById;
        service.getRestangularObj = getRestangularObj;
        service.highlightMarkers = highlightMarkers;
        service.resetMarkersColor = resetMarkersColor;
        service.unHighlightMarker = unHighlightMarker;
        service.animateMarker = animateMarker;
        service.clearAnimationMarker = clearAnimationMarker;
        service.deleteBranch = deleteBranch;
        //service.closeInfoWindowById = closeInfoWindowById;

        function saveBranch (data, id) {
            var dfd = $q.defer();

            if (id) { // update
                var restObj = Branch.cast(id);
                restObj.customPUT(data)
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            } else { // insert
                Branch.post(data)
                    .then(function(response){
                        dfd.resolve(response.plain());
                    }, function(error){
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function getBranchIconByType (type) {
            if (!type) return iconBaseUrl + unhighlightIcon;

            return iconBaseUrl + branchIcons[type.toLowerCase()];
        }

        function loadMarkers (list) {
            var marker;

            hideMarkers();

            branchMarkers = [];

            if (!branchInfowindow) branchInfowindow = gmapServices.createInfoWindow('');

            list.forEach(function (item) {
                marker = gmapServices.initMarker(item.latlng, getBranchIconByType(item.type), {zIndex: 1});

                //marker.infowindow = gmapServices.createInfoWindow('');
                //marker.infowindow.branchId = item.id;

                marker.content = '<div>';
                marker.content += '<h3 class="no-margin padding-left-5"><b>' + item.name + '</b></h3>';
                marker.content += '<h4 class="no-margin text-muted padding-left-5">' + item.type + '</h4>';

                marker.content += '<button id="compare-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-primary">Compare</button>'

                if ($rootScope.currentUser.role === 'ADMIN') {
                    marker.content += '<button id="edit-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-default">Edit</button>';
                    marker.content += '<button id="delete-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-warn">Delete</button>';
                }

                marker.content += '</div>';

                marker.branch = angular.copy(item);
                marker.id = item.id;

                gmapServices.addListener(marker, 'click', function () {
                    //this.infowindow.open(gmapServices.map, this);
                    //this.infowindow.setContent(this.content);
                    branchInfowindow.open(gmapServices.map, this);
                    branchInfowindow.setContent(this.content);
                });

                //google.maps.event.addListener(marker.infowindow, 'closeclick', function () {
                //    console.log('infowindow close.!');
                //    // if current branch was added as compare then remove it on the table when infowindow closed
                //    $rootScope.$broadcast('branch-infowindow-closed', {id: this.branchId});
                //});

                branchMarkers.push(marker);
            });

            $rootScope.$broadcast('compile-map-legend', {type: 'branches', data: getMapLegendData(list)});
        }

        function getMapLegendData (list) {
            return _.pluck(_.uniq(list, function(item){
                return item.type;
            }), 'type').map(function(type){
                return {
                    name: type,
                    iconUrl: getBranchIconByType(type)
                };
            });
        }

        function showMarkers() {
            branchMarkers.forEach(function (marker) {
                if (marker && !marker.getVisible()) marker.setVisible(true);
            });
        }

        function hideMarkers () {
            branchMarkers.forEach(function (marker) {
                if (marker && marker.getVisible()) marker.setVisible(false);
            });
        }

        function toggle () {
            if (branchMarkers.length) {
                if (branchMarkers[0].getVisible()) {
                    hideMarkers();
                } else {
                    showMarkers();
                }
            }
        }

        function dismissInfowindow () {
            if (branchInfowindow) branchInfowindow.close();
        }

        function getBranchById (branchId) {
            return _.findWhere(branchMarkers, {id: branchId});
        }

        function getRestangularObj(branchId) {
            return Branch.cast(branchId);
        }

        function highlightMarkers (branchIds) {
            var icon,
                isFound;

            branchMarkers.forEach(function(item){
                isFound = branchIds.indexOf(item.id) > -1;

                icon = branchIds.indexOf(item.id) > -1
                       ? getBranchIconByType(item.branch.type)
                       : getBranchIconByType();

                item.setIcon(icon);

                if (isFound) item.setZIndex(2);
            });
        }

        function resetMarkersColor () {
            var icon;

            branchMarkers.forEach(function (item) {
                icon = getBranchIconByType(item.branch.type)
                item.setIcon(icon);
                item.setZIndex(1);
            });
        }

        function unHighlightMarker (branchId) {
            var found = getBranchById(branchId);

            if (!found) return;

            found.setIcon(getBranchIconByType());
            found.setZIndex(1);
            found.setAnimation(null);
        }

        function animateMarker (branchId) {
            var found = getBranchById(branchId);

            if (!found) return;

            //gmapServices.panToMarker(found);
            found.setAnimation(google.maps.Animation.BOUNCE);
        }

        function clearAnimationMarker (branchId) {
            var found = getBranchById(branchId);

            if (!found) return;

            found.setAnimation(null);
        }

        function deleteBranch(branchId) {
            var dfd = $q.defer();

            var restObj = getRestangularObj(branchId);

            restObj.remove()
                .then(function (response) {

                    dismissInfowindow();

                    var index = _.findIndex(branchMarkers, {id: branchId});

                    if (index > -1) {
                        if (branchMarkers[index] && branchMarkers[index].getMap()) {
                            branchMarkers[index].setVisible(false);
                            gmapServices.clearInstanceListeners(branchMarkers[index]);
                            branchMarkers[index].setMap(null);
                            branchMarkers[index] = null;
                            console.log('clearing branch marker');
                        }
                        branchMarkers.splice(index, 1);
                    }

                    dfd.resolve(response);
                }, function (error) {
                    console.log('error: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('Branch', ['Restangular', Branch]);
    
    function Branch (Restangular) {
        var myModel = Restangular.all('branches');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'branches');
            }
        };

        Restangular.extendModel('branches', function (model) {
            //model.deletePanel = function (panel_id) {
            //    return model
            //        .one('panels', panel_id)
            //        .remove();
            //};
            //
            //model.upload = function (_file, _caption) {
            //    var uploadUrl = model.getRestangularUrl() + '/' + 'photos',
            //        caption = _caption || '';
            //    return Upload.upload({
            //               url: uploadUrl,
            //               method: 'POST',
            //               data: {file: _file, caption: caption}
            //           });
            //};
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp', [
            'restangular',
            'LocalStorageModule',
            'ngMaterial',
            'ngAnimate',
            'oitozero.ngSweetAlert',
            'ngFileUpload',
            'md.data.table',
            'demoApp.home',
            'demoApp.admin',
            'demoApp.sales'
        ])

        .constant('APP_NAME', 'UNILAB')
        .constant('BASE_URL', window.location.origin)
        .constant('MARKER_BASE_URL', '/images/markers/')

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }])

        .config(["localStorageServiceProvider", function (localStorageServiceProvider) {
            localStorageServiceProvider
                .setPrefix('UNILAB')
                .setStorageType('sessionStorage')
                .setNotify(true, true)
            ;
        }])

        .run(["userSessionService", "$rootScope", function(userSessionService, $rootScope){
            userSessionService.userLogin()
                .then(function (user) {
                    $rootScope.currentUser = angular.copy(user);
                });
        }])

        .filter('underscoreless', function () {
            return function (input) {
                return input.replace(/_/g, ' ');
            };
        })
        .config(["$mdThemingProvider", function ($mdThemingProvider) {
        //    $mdThemingProvider.theme('default')
        //        .primaryPalette('red')
        //        .accentPalette('pink');
            $mdThemingProvider.theme('docs-dark', 'default')
                .primaryPalette('yellow')
                .dark();
        }])
    ;

}());

String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
};


(function () {
    'use strict';

    angular.module('demoApp')
        .controller('searchAddressBarController', ['$rootScope', 'gmapServices', 'alertServices', 'locationService', searchAddressBarController]);

    function searchAddressBarController($rootScope, gmapServices, alertServices, locationService) {
        var vm = this;

        var autocomplete = null;

        vm.getGPSLocation = getGPSLocation;

        initialize();

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input', {
                componentRestrictions: {country: 'ph'}
            });

            autocomplete.addListener('place_changed', placeChangeCallback);

            $rootScope.$on('clear-search-address-bar', function(e){
                vm.query = '';
            });
        }

        function placeChangeCallback() {
            var place = autocomplete.getPlace();

            if (!place.geometry) {
                alertServices.showInfo("Address not found.");
                return;
            }

            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }

            $rootScope.$broadcast('search-address-return-result', {result: place});
        }

        function getGPSLocation () {
            locationService.getCurrentLocation()
                .then(function(latlng){
                    gmapServices.reverseGeocode(latlng)
                        .then(function (result) {
                            if (result.length) $rootScope.$broadcast('search-address-return-result', {result: result[0]});
                        });
                }, function (error){
                    alertServices.showError(error.message);
                });
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('placesService', ['Place', '$rootScope', '$q', 'gmapServices', placesService]);

    function placesService (Place, $rootScope, $q, gmapServices) {
        var service = {};

        var placeTypesDelimiter = '|';

        var iconByplaceTypes = {
            'hospital': {
                icon: 'hospital',
                color: '#E91E63'
            },
            'pharmacy': {
                icon: 'health',
                color: '#9b59b6'
            },
            'shopping_mall': {
                icon: 'department-store',
                color: '#9b59b6'
            },
            'school': {
                icon: 'school',
                color: '#7f8c8d'
            },
            'convenience_store': {
                icon: 'convenience-store',
                color: '#f39c12'
            }
        };

        service.defaultPlaceTypes = [
            //'hospital',
            //'pharmacy'
        ];

        var poiMarkers = [],
            poiInfowindow;

        var abort1,
            abort2;

        service.loadPOIs = loadPOIs; // load within territory
        service.loadPOIsWithinBoundary = loadPOIsWithinBoundary;
        service.showPOIs = showPOIs;
        service.showPOIByType = showPOIByType;
        service.showVisiblePOIs = showVisiblePOIs;
        service.hidePOIs = hidePOIs;
        service.getPlaceTypes = getPlaceTypes;

        function loadPOIs (territoryId, typesArray) {
            var dfd = $q.defer();

            if (abort1) abort1.resolve();

            abort1 = $q.defer();

            Place.withHttpConfig({timeout: abort1.promise})
                .get('', {types: typesArray.join(placeTypesDelimiter), territoryid: territoryId})
                .then(function(response){
                    dfd.resolve(response.data);
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function loadPOIsWithinBoundary(boundaryId, typesArray) {
            var dfd = $q.defer();

            if (abort2) abort2.resolve();

            abort2 = $q.defer();

            Place.withHttpConfig({timeout: abort2.promise})
                .get('', {types: typesArray.join(placeTypesDelimiter), boundaryid: boundaryId})
                .then(function (response) {
                    console.log('places: ',response);
                    dfd.resolve(response.data);
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function showPOIs(list) {
            var marker,
                placeType;

             if (!poiInfowindow) poiInfowindow = gmapServices.createInfoWindow('');

            hidePOIs();

            poiMarkers = [];

            for (var poiType in list) {
                list[poiType].forEach(function (item) {
                    placeType = getPlaceIcon(item.type);
                    marker = gmapServices.createMapIconLabel(item.geometry.location, placeType.icon || 'compass', placeType.color);
                    marker.name = item.name;
                    marker.type = item.type;
                    marker.content = '<b>' + item.name + '</b>';
                    marker.content += '<br>' + marker.type;

                    gmapServices.addListener(marker, 'click', function () {
                        poiInfowindow.open(gmapServices.map, this);
                        poiInfowindow.setContent(this.content);
                    });

                    poiMarkers.push(marker);
                });
            }

            $rootScope.$broadcast('compile-map-legend', {type: 'places', data: getMapLegendData(list)});
        }

        function getMapLegendData(list) {
            return Object.keys(list).map(function(type){
                return {
                    name: type.capitalize(),
                    iconPlace: getPlaceIcon(type)
                };
            });
        }

        function showPOIByType(type) {
            if (type == 'all') {
                poiMarkers.forEach(function (marker) {
                    if (!marker.getMap()) marker.setMap(gmapServices.map);
                });
                return;
            }

            poiMarkers.forEach(function (marker) {
                if (type != marker.type) {
                    marker.setMap(null);
                    return;
                }

                if (!marker.getMap()) marker.setMap(gmapServices.map);
            })
        }

        function showVisiblePOIs () {
            poiMarkers.forEach(function (marker) {
                if (marker && !marker.getMap()) marker.setMap(gmapServices.map);
            });
        }

        function hidePOIs() {
            poiMarkers.forEach(function (marker) {
                if (marker && marker.getMap()) marker.setMap(null);
            });
        }

        function getPlaceTypes() {
            var result = [];
            for (var key in iconByplaceTypes) {
                result.push(key);
            }
            return result;
        }

        function getPlaceIcon(placeType) {
            return iconByplaceTypes[placeType];
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Place', ['Restangular', Place]);

    function Place(Restangular) {
        var myModel = Restangular.all('places');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'places');
            }
        };

        Restangular.extendModel('places', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            return Restangular.stripRestangular(model);
            //return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        var newTransactionModal,
            mapPlotOptionsModal;

        /* Service Functions */
        service.showNewBranchForm = showNewBranchForm;
        service.showNewTransactionForm = showNewTransactionForm;
        service.showMapPlotOptions = showMapPlotOptions;
        //service.showProjectDetail = showProjectDetail;
        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        function showNewBranchForm(ev, params) {
            var opts = {
                controller: 'newBranchController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_new_branch.html',
                parent: angular.element(document.querySelector('#index-container')),
                locals: {param: params},
                targetEvent: ev,
                hasBackdrop: false,
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(newTransactionModal, opts);
        }

        function showNewTransactionForm(ev, params) {
            var opts = {
                controller: 'newTransactionController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_new_transaction.html',
                parent: angular.element(document.querySelector('#index-container')),
                locals: {param: params},
                targetEvent: ev,
                hasBackdrop: false,
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(newTransactionModal, opts);
        }

        function showMapPlotOptions () {
            var opts = {
                controller: 'mapPlotOptionsController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/_map_plot_options.html',
                parent: angular.element(document.querySelector('body')),
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(mapPlotOptionsModal, opts);
        }

        //function showProjectDetail(proj) {
        //    var opts = {
        //        controller: 'projectDetailsController',
        //        controllerAs: 'vm',
        //        templateUrl: '/partials/modals/_view-project.tmpl.html',
        //        parent: angular.element(document.querySelector('#admin-container')),
        //        hasBackdrop: false,
        //        locals: {project: proj},
        //        fullscreen: $mdMedia('xs'),
        //        onComplete: function (scope, element, options) {
        //            $('.md-scroll-mask').css('z-index', '-1');
        //        }
        //    };
        //    return showModal(projectDetailModal, opts);
        //}

        function hideResolveModal(response) {
            $rootScope.$broadcast("modal-closed");
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $rootScope.$broadcast("modal-closed");
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mapPlotOptionsController', ['modalServices', mapPlotOptionsController]);

    function mapPlotOptionsController (modalServices) {
        var vm = this;

        vm.options = [
            {
                name: 'New Branch',
                action: 'showNewBranchForm'
            },
            {
                name: 'New Sales Transaction',
                action: 'showNewTransactionForm'
            }
        ];

        vm.selectOption = selectOption;
        vm.cancel = cancel;

        function selectOption (opt) {
            modalServices.hideResolveModal(opt);
        }

        function cancel () {
            modalServices.closeModal();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mapLegendController', ['$rootScope', mapLegendController]);

    function mapLegendController ($rootScope) {
        var vm = this;

        vm.legendData = {};
        vm.close = close;

        initialize();

        function initialize () {
            $rootScope.$on('compile-map-legend', function (e, params) {
                vm.legendData[params.type] = params.data;

                if (!$rootScope.showLegend) $rootScope.showLegend = true;
            });
        }

        function close () {
            $rootScope.showLegend = false;
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('mainController', ['$rootScope', 'APP_NAME', '$mdSidenav', 'userSessionService', 'alertServices', 'branchService', mainController]);

    function mainController($rootScope, APP_NAME, $mdSidenav, userSessionService, alertServices, branchService) {
        var vm = this;

        $rootScope.appName = APP_NAME;
        $rootScope.showLegend = false;

        /* Side Nav Menus */
        vm.menu = [];

        var MENU_SELECTIONS = [
            {
                link: '/',
                title: 'Home',
                icon: 'home',
                can: ['ADMIN', 'SALES']
            },
            {
                link: '/channeldiversification',
                title: 'Channel Diversification',
                icon: 'track_changes',
                can: ['ADMIN', 'SALES']
            },
            {
                link: '/frauddetect',
                title: 'Fraud Detection',
                icon: 'fingerprint',
                can: ['ADMIN']
            },
            {
                link: '/productsaturation',
                title: 'Product Saturation',
                icon: 'assessment',
                can: ['ADMIN']
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app',
                can: ['ADMIN', 'SALES']
            }
        ];

        var branchId,
            branchMarker;

        $rootScope.showBranchCompareTable = false;

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');
        vm.onMenuItemClick = onMenuItemClick;
        vm.showBanchCompareTableAction = showBanchCompareTableAction;
        vm.showTerritoryPanelDetail = showTerritoryPanelDetail;
        vm.showLegendPanel = showLegendPanel;

        initialize();

        function initialize () {
            // loads user details
            $rootScope.$watch('currentUser', function(newValue, oldValue){
                if (!newValue) return;
                vm.menu = getUserMenu(newValue);
            });

            // Compare Branch
            $(document).on('click', '#compare-branch-btn', function () {
                branchId = $(this).data('branch-id');
                branchMarker = branchService.getBranchById(branchId);

                if (branchMarker) {
                    $rootScope.$broadcast('close-territory-info-panel');
                    $rootScope.showBranchCompareTable = true;

                    var restObj = branchService.getRestangularObj(branchMarker.branch.id);

                    // get branch products
                    restObj.getList('products')
                        .then(function(response){
                            branchMarker.branch.products = angular.copy(response.plain());
                            $rootScope.$broadcast('new-compare-branch', branchMarker.branch);
                            branchService.dismissInfowindow();
                        });
                }
            });

            // Edit Branch
            $(document).on('click', '#edit-branch-btn', function () {
                branchId = $(this).data('branch-id');
                console.log('edit branch with id = ' + branchId);
                // TODO: show edit modal
                branchMarker = branchService.getBranchById(branchId);
            });

            // Delete Branch
            $(document).on('click', '#delete-branch-btn', function () {
                branchId = $(this).data('branch-id');

                alertServices.showConfirm('Delete Branch', 'Are your sure you want to delete this branch?', function (isConfirm) {
                    if (isConfirm) {
                        branchService.deleteBranch(branchId)
                            .then(function(response){
                                alertServices.showSuccess('Branch successfully deleted.');
                            });
                    }
                })
            });

            $rootScope.$on('modal-opened', function() {
                $rootScope.hasOpenedModal = true;
            });

            $rootScope.$on('modal-closed', function () {
                $rootScope.hasOpenedModal = false;
            });
        }

        function getUserMenu (user) {
            // TODO: this must come from backend
            var result = [];

            MENU_SELECTIONS.forEach(function(item){
                if (item.can.indexOf(user.role.toUpperCase()) > -1) return result.push(item);
            });

            return result;
        }

        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle();
            }
        }

        function onMenuItemClick (item) {
            if (item.title.toLowerCase() == 'logout') {
                // clean local storage
                userSessionService.userLogout();
            }

            window.location.href = item.link;
        }

        function showBanchCompareTableAction () {
            $rootScope.showBranchCompareTable = true;
        }

        function showTerritoryPanelDetail() {
            $mdSidenav('territoryInfoPanelSidenav')
                .open()
                .then(function () {
                    $rootScope.showTerritoryDetailBtn = false;
                    $rootScope.showGRDPPanel = true;
                });
        }

        function showLegendPanel() {
            $rootScope.showLegend = true;
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('locationService', ['$q', 'gmapServices', locationService]);

    function locationService($q, gmapServices) {
        var service = {};

        service.getCurrentLocation = getCurrentLocation;
        service.showCurrentLocation = showCurrentLocation;
        service.showDraggableLocation = showDraggableLocation;

        function transformResponse (response) {
            return {
                lat: response.coords.latitude,
                lng: response.coords.longitude
            };
        }

        function getCurrentLocation () {
            if (!navigator.geolocation) {
                console.log('Browser doesnt support Geolocation');
                return false;
            }

            var dfd = $q.defer();

            navigator.geolocation.getCurrentPosition(function (response) {
                dfd.resolve(transformResponse(response));
            }, function (error){
                console.log('get current position error: ', error);
                dfd.reject(error);
            });

            return dfd.promise;
        }

        // Parameter must be a latLng
        function showCurrentLocation (position) {
            var latLng = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };

            var marker = gmapServices.showCurrentLocation(latLng);
            var offset = 0.002;


            gmapServices.panToOffsetLeft(latLng, offset);
            gmapServices.setZoomInDefault();

            return marker;
        }

        function showDraggableLocation () {
            var draggable = true,
                latLng = gmapServices.map.getCenter();

            var marker = gmapServices.showCurrentLocation(latLng, draggable);

            return marker;
        }

        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(10.3194669, 123.9136565);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.initializeGeocoder = initializeGeocoder;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.panToMarker = panToMarker;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.createMapIconLabel = createMapIconLabel;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            //$(myMapId).height($(window).height() - (42));
            $(myMapId).height($(window).height());

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //initializeGeocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function initializeGeocoder () {
            service.geocoder = new google.maps.Geocoder();
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if (!(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function (infobox, index) {
                if (infobox) {
                    infobox.close();
                }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            var marker = service.initMarker(_position, _color);

            //service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            return service.initMarker(_position, icon);
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if (_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else {
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function createCircle(centerLatLng, radiusParam, color) {
            return new google.maps.Circle({
                strokeColor: color || '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: color || '#FF0000',
                fillOpacity: 0.35,
                map: service.map,
                center: centerLatLng,
                radius: radiusParam
            });
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.map.setCenter(bounds.getCenter());
        }

        function panToMarker(marker) {
            if (!service.map || !marker) return;

            service.map.panTo(marker.getPosition());
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable()) google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable()) google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable()) google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) {
                initializeGeocoder();
            }

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if (layerName == 'meters') {
                return defaultStyle;
            } else if (layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if (layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId, opts) {
            var input = document.getElementById(elementId);
            var mergeOpts = angular.merge({
                types: ["geocode"]
            }, opts)

            var autocomplete = new google.maps.places.Autocomplete(input, mergeOpts);

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation(latLng, polygon) {
            if (!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent(obj, event) {
            google.maps.event.trigger(obj, 'click');
        }

        function createMapIconLabel(latLng, type, color) {
            return new Marker({
                map: service.map,
                position: latLng,
                icon: {
                    anchor: new google.maps.Point(-6, -10),
                    path: MAP_PIN,
                    fillColor: color || '#2ecc71',
                    fillOpacity: 1,
                    strokeColor: color ? '' : '#27ae60',
                    strokeWeight: color ? 0 : 1
                },
                map_icon_label: '<span class="map-icon map-icon-' + type + '"></span>'
            });
        }

        service.createFacilityMarker = createFacilityMarker;

        function createFacilityMarker(latLng) {
            return service.initMarker(latLng, 'resources/images/markers/wifi.png');
        }

        return service;
    }
}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('formHelperService', [formHelperService]);

    function formHelperService () {
        var service = {};

        service.getDateFormatted = getDateFormatted;
        service.showFormErrors = showFormErrors;
        service.getFormattedErrors = getFormattedErrors;

        function getDateFormatted(date) {
            return date.getFullYear() + '-' + (date.getMonth()+1) + '-' + date.getDate();
        }

        // ex param. vm.form.$error
        function showFormErrors(formError) {
            angular.forEach(formError, function (field) {
                angular.forEach(field, function (errorField) {
                    errorField.$setTouched();
                })
            });
        }

        function getFormattedErrors(data) {
            var message = '',
                error;

            for (var key in data.errors) {
                error = data.errors[key];
                if (error.length) {
                    message += key.capitalize() + ' : ' + error[0] + '\n';
                }
            }

            return message;
        }


        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Boundary', ['Restangular', Boundary]);

    function Boundary(Restangular) {
        var myModel = Restangular.all('boundaries');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'boundaries');
            }
        };

        Restangular.extendModel('boundaries', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('boundariesService', ['Boundary', '$q', boundariesService]);

    function boundariesService (Boundary, $q) {
        var service = {};

        service.boundaries = [];

        service.loadBoundaries = loadBoundaries;
        service.getRestangularObj = getRestangularObj;

        function loadBoundaries(parentid) {
            var dfd = $q.defer();

            Boundary.customGET(null, {parent_id: parentid || null})
                .then(function (list) {
                    //console.log('load boundaries: ', list);
                    service.boundaries = list.plain().map(function (item) {
                        item['isExpanded'] = false;
                        return item;
                    });

                    dfd.resolve(list.plain());
                }, function (error) {
                    console.log('failed to load: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getRestangularObj (boundaryId) {
            return Boundary.cast(boundaryId);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        //service.showFilterSelectionEmpty = showFilterSelectionEmpty;
        service.showConfirm = showConfirm;
        service.showSuccess = showSuccess;
        service.showInfo = showInfo;
        service.showError = showError;

        function showToast(message, position, delay) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(delay || 2000)
            );
        }

        function showBottomLeftToast(message, delay) {
            showToast(message, 'bottom left', delay);
        }

        function showTopRightToast(message, delay) {
            showToast(message, 'top right', delay);
        }

        function showMessage(message, type) {
            SweetAlert.swal({
                title: message,
                type: type
            });
        }

        function showSuccess(message) {
            showMessage(message, 'success');
        }

        function showError(message) {
            showMessage(message, 'error');
        }

        function showNoDataAvailablePrompt(entityName) {
            service.showBottomLeftToast('No ' + entityName + ' data available for this area.');
        }

        function showConfirm (title, message, callbackOnConfirm) {
            SweetAlert.swal({
                    title: title,
                    text: message,
                    type: "warning",
                    showCancelButton: true,
                    confirmButtonColor: "#DD6B55",
                    confirmButtonText: "Yes",
                    closeOnConfirm: true
                },
                callbackOnConfirm);
        }

        function showInfo(message) {
            showMessage(message, 'info');
        }


        //function showFilterSelectionEmpty() {
        //    showMessage('Please select filter type.', 'warning');
        //}
        //
        //function showQueryIsEmpty() {
        //    showMessage('Please fill in search query.', 'info');
        //}

        return service;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.admin', []);

}());

(function(){
'use strict';

angular.module('demoApp.admin')
    .controller('adminPanelController', ['$rootScope', '$scope', 'boundariesService', 'branchService', 'userTerritoriesService', '$timeout', 'gmapServices', '$q', 'alertServices', 'placesService', '$mdSidenav', adminPanelController]);

    function adminPanelController ($rootScope, $scope, boundariesService, branchService, userTerritoriesService, $timeout, gmapServices, $q, alertServices, placesService, $mdSidenav) {
        var vm = this;

        var polygonObj;

        var selectedTypes = [],
            foundTypeIndex,
            isSelected;

        var promises = [];
        var aborts = {};

        vm.boundaries = [];
        vm.territories = [];
        vm.showTerritoriesPanel = false;

        vm.expandCallback = expandCallback;
        vm.showBoundary = showBoundary;
        vm.showTerritory = showTerritory;
        vm.toggleType = toggleType;

        initialize();

        function initialize () {
            boundariesService.loadBoundaries()
                .then(function (list) {
                    vm.boundaries = angular.copy(list);
                }, function (error) {
                    console.log('failed to load: ', error);
                });

            var rawTypes = placesService.getPlaceTypes().map(function (type) {
                foundTypeIndex = placesService.defaultPlaceTypes.indexOf(type);
                isSelected = false;

                // initially select default place type
                if (foundTypeIndex !== -1) {
                    selectedTypes.push(type);
                    isSelected = true;
                }

                return {
                    name: type,
                    model: isSelected
                }
            });

            vm.placeTypes = _.groupBy(rawTypes, function (item, index) {
                return index % 2;
            });

            $rootScope.$watch('currentUser', function (newValue, oldValue) {
                if (!newValue) return;

                userTerritoriesService.getTerritories()
                    .then(function (territories) {
                        vm.territories = _.uniq(territories, true, function (item) {
                            return item.territoryid;
                        });
                    });
            });

            $scope.$watch(function(){
                return vm.loadPois;
            }, function(newValue, oldValue){
                if (newValue === oldValue) return;

                if (newValue) {
                    placesService.showVisiblePOIs();
                    return;
                }

                placesService.hidePOIs();
            });
        }

        function showPolygon(latLngArray, isTerritory) {
            if (!latLngArray.length) {
                alertServices.showError('Cannot load polygon, data error.');
                return;
            }

            var color = isTerritory ? '#3f51b5' : '#ff0000';

            if (polygonObj) {
                polygonObj.setPath(latLngArray);
                polygonObj.setOptions({
                    fillColor: color,
                    strokeColor: color,
                });
            } else {
                polygonObj = gmapServices.createPolygon(latLngArray, color);
            }
        }

        function toggleType(type) {
            var arr = vm.placeTypes['0'].concat(vm.placeTypes['1']);
            var val = _.findWhere(arr, {name: type});

            var index = selectedTypes.indexOf(val.name);

            if (val.model && index === -1) {
                selectedTypes.push(val.name)
            } else if (index !== -1) {
                selectedTypes.splice(index, 1);
            }
        }

        function showBoundary(boundary, isParent) {
            var item = boundariesService.getRestangularObj(boundary.id);

            for (var k in aborts) {
                if (aborts[k]) aborts[k].resolve();
            }

            aborts = {
                detail: $q.defer(),
                branches: $q.defer()
            };

            if (boundary.typeid == 6) {
                $('v-pane#' + boundary.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'block'});
            } else {
                $('md-list-item#' + item.id.toString() + ' md-progress-circular').show();
            }

            branchService.hideMarkers();
            placesService.hidePOIs();

            promises.push(
                item.withHttpConfig({timeout: aborts.detail.promise})
                    .get()
                    .then(function (response) {
                        var resp = response.plain();

                        showPolygon(resp.geometry);
                        gmapServices.setZoomIfGreater(12);
                        gmapServices.panToPolygon(polygonObj);
                    })
            );

            // load branches
            promises.push(
                item.withHttpConfig({timeout: aborts.branches.promise})
                    .getList('branches')
                    .then(function (response) {
                        var resp = response.plain();

                        if (!resp.length) {
                            alertServices.showBottomLeftToast(boundary.name.capitalize() + ' doesnt have branch yet.');
                            return;
                        }

                        branchService.loadMarkers(resp.map(function (item) {
                            return item.branch;
                        }));
                    })
                    .finally(function () {
                        $timeout(function () {
                            if (boundary.typeid == 6) $('v-pane#' + boundary.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'none'});
                            else $('md-list-item#' + item.id.toString() + ' md-progress-circular').hide();
                        }, 500);
                    })
            );

            // load places
            if (vm.loadPois && !isParent) {
                promises.push(
                    placesService.loadPOIsWithinBoundary(boundary.id, selectedTypes)
                        .then(function (response) {
                            placesService.showPOIs(response);
                        })
                );
            }

            //$q.all(promises)
            //    .finally(function(){
            //        $timeout(function () {
            //            if (boundary.typeid == 6) $('v-pane#' + boundary.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'none'});
            //            else $('md-list-item#' + item.id.toString() + ' md-progress-circular').hide();
            //        }, 500);
            //    });
        }

        function expandCallback(item, event) {
            event.stopPropagation();

            if (item.isExpanded === false) return;

            if (item.typeid < 7) {
                if (item.hasOwnProperty('children') && item.children.length) return;

                $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'block'});

                item.children = [];

                $('v-pane#' + item.id.toString() + ' v-pane-content v-accordion').children().html('');

                boundariesService.loadBoundaries(item.id)
                    .then(function (list) {
                        if (list.length) item.children = angular.copy(list);
                    }, function (error) { console.log('failed to load: ', error); })
                    .finally(function () {
                        if (item.typeid == 6) {
                            showBoundary(item, true);
                        } else {
                            $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').css({'display': 'none'});
                        }
                    });

                return;
            }

            showBoundary(item);

            return;
        }

        function showTerritory (item) {
            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').show();

            branchService.hideMarkers();
            placesService.hidePOIs();

            $rootScope.selectedTerritory = item;

            showPolygon(item.territory.geom, true);
            gmapServices.setZoomIfGreater(10);
            gmapServices.panToPolygon(polygonObj);

            var promises = [];

            // load places
            if (vm.loadPois) {
                promises.push(
                    placesService.loadPOIs(item.territoryid, selectedTypes)
                        .then(function (response) {
                            placesService.showPOIs(response);
                            $rootScope.selectedTerritory.places = response;
                        })
                );
            }

            promises.push(
                userTerritoriesService.getTerritoryBranches(item.territoryid)
                    .then(function (response) {

                        if (!response.length) {
                            alertServices.showBottomLeftToast('This territory doesnt have branch yet.');
                        } else {
                            $rootScope.selectedTerritory.branches = response;
                            branchService.loadMarkers(response);
                        }

                        $timeout(function () {
                            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
                        }, 500);

                        $mdSidenav('territoryInfoPanelSidenav').open();
                        $rootScope.$broadcast('territory_selected', $rootScope.selectedTerritory);
                    })
            );
        }

    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.sales', []);

}());

(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('territoryInfoPanelController', ['$rootScope', 'branchService', 'placesService', '$mdSidenav', territoryInfoPanelController]);

    function territoryInfoPanelController ($rootScope, branchService, placesService, $mdSidenav) {
        var vm = this;

        vm.showPOIByType = showPOIByType;
        vm.toggleBranches = toggleBranches;
        vm.close = close;

        initialize();

        function initialize () {
            $rootScope.$on('territory_selected', function (e, data) {
                vm.territory = angular.copy(data);

                if (!vm.territory.places) return;

                var allPlaces = [];
                for (var k in vm.territory.places) {
                    vm.territory.places[k].forEach(function (item) {
                        allPlaces.push(item);
                    });
                }
                vm.territory.places['all'] = allPlaces;
            });

            $rootScope.$on('close-territory-info-panel', function(){
               close();
            });
        }

        function showPOIByType (type) {
            placesService.showPOIByType(type);
        }

        function toggleBranches () {
            branchService.toggleMarkers();
        }

        function close () {
            //$rootScope.showGRDPPanel = false;

            $mdSidenav('territoryInfoPanelSidenav')
                .close()
                .then(function () {
                    $rootScope.showTerritoryDetailBtn = true;
                });
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp.sales')
        .factory('Territory', ['Restangular', Territory]);

    function Territory(Restangular) {
        var myModel = Restangular.all('territories');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'territories');
            }
        };

        Restangular.extendModel('territories', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('salesPanelController', ['$q', '$rootScope', '$timeout', 'userTerritoriesService', 'gmapServices', 'branchService', '$mdSidenav', 'placesService', salesPanelController]);

    function salesPanelController ($q, $rootScope, $timeout, userTerritoriesService, gmapServices, branchService, $mdSidenav, placesService) {
        var vm = this;

        var polygonTerritory;

        vm.territories = [];

        vm.filter = {
            q: ''
        };

        vm.toggleToolbarPanel = toggleToolbarPanel;
        vm.showTerritoryDetails = showTerritoryDetails;

        initialize();

        function initialize () {
            $rootScope.$watch('currentUser', function (newValue, oldValue) {
                if (!newValue) return;

                userTerritoriesService.getTerritories()
                    .then(function (territories) {
                        vm.territories = angular.copy(territories);
                    });
            });
        }

        function toggleToolbarPanel () {
            vm.filter.q = '';
            vm.showFilterPanel = !vm.showFilterPanel;
        }

        function showPolygonTerritory(latLngArray) {
            if (polygonTerritory) {
                polygonTerritory.setPath(latLngArray);
                return;
            }
            polygonTerritory = gmapServices.createPolygon(latLngArray, '#3f51b5');
        }

        function showTerritoryDetails (item) {
            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').show();

            $rootScope.selectedTerritory = item;

            showPolygonTerritory(item.territory.geom);

            gmapServices.setZoomIfGreater(12);
            gmapServices.panToPolygon(polygonTerritory);

            // load places
            // TODO: uncomment this after working on other features to avoid gmap credits toll
            //var dfd1 = placesService.loadPOIs(item.territoryid)
            //            .then(function(response){
            //                placesService.showPOIs(response);
            //                $rootScope.selectedTerritory.places = response;
            //            });

            var dfd2 = userTerritoriesService.getTerritoryBranches(item.territoryid)
                .then(function (response) {
                    $rootScope.selectedTerritory.branches = response;
                    branchService.loadMarkers(response);
                });

            $q.all([dfd2])
                .then(function(){
                    $mdSidenav('territoryInfoPanelSidenav').open();
                    $rootScope.$broadcast('territory_selected', $rootScope.selectedTerritory);
                })
                .finally(function(){
                    $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
                });


        }


    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('salesPageController', ['gmapServices', '$rootScope', '$mdSidenav', salesPageController]);

    function salesPageController (gmapServices, $rootScope, $mdSidenav) {
        var vm = this;

        vm.showTerritoryPanelDetail = showTerritoryPanelDetail;

        initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');
        }

        function showTerritoryPanelDetail () {
            $mdSidenav('territoryInfoPanelSidenav')
                .open()
                .then(function () {
                    $rootScope.showTerritoryDetailBtn = false;
                    $rootScope.showGRDPPanel = true;
                });
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.sales')
    .controller('compareBranchesTableController', ['$rootScope', '$scope', compareBranchesTableController]);

    function compareBranchesTableController ($rootScope, $scope) {
        var vm = this;

        vm.branchCompareList = [];
        $rootScope.showBranchCompareTable = false;
        vm.currentIndex = 0;

        vm.removeBranch = removeBranch;
        vm.close = close;

        initialize();

        function initialize() {

            $scope.$watchCollection(function () {
                return vm.branchCompareList;
            }, function (newCollection) {
                if (newCollection.length) {
                    $rootScope.showBranchCompareTable = true;
                    $('#show-compare-branches-btn').show();
                    return;
                }

                $rootScope.showBranchCompareTable = false;
                $('#show-compare-branches-btn').hide();
            });

            $rootScope.$on('new-compare-branch', function (e, branch) {

                if (_.findWhere(vm.branchCompareList, {id: branch.id})) return;

                vm.branchCompareList.push(transform(branch));

                compileList();

                console.log('list: ', vm.list);
            });

            //$rootScope.$on('branch-infowindow-closed', function(e, obj) {
            //    console.log('branch-infowindow-closed ',obj);
            //    removeBranch({id: obj.id});
            //});
        }

        function transform (obj) {
            var result = {};

            result['id'] = obj.id;
            result['name'] = obj.name;

            obj.products.forEach(function(prod){
               result[prod.product.name] = prod.product.name;
            });

            return result;
        }

        function indexByAttribute(collection) {
            return collection.reduce(function (result, item) {

                angular.forEach(item, function (value, index) {
                    result[index] = result[index] || [];
                    result[index].push(value);
                });

                return result;
            }, {});
        }

        function compileList () {
            vm.list = indexByAttribute(vm.branchCompareList);
        }

        function removeBranch(branchId) {
            console.log('removeBranch: ',branchId);
            var index = _.findIndex(vm.branchCompareList, {id: branchId});
            console.log('removeBranch: ',index);
            if (index > -1) {
                vm.branchCompareList.splice(index, 1);
                compileList();

                if($scope.$$phase) return;

                $scope.$apply(function(){
                    return vm.list;
                });
                //branchService.closeInfoWindowById(branch.id);
            }
        }

        function close () {
            $rootScope.showBranchCompareTable = false;
        }

    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.home', [
            'vAccordion'
        ]);

}());

(function(){
'use strict';

angular.module('demoApp.home')
    .factory('userTerritoriesService', ['$q', '$rootScope', 'userSessionService', 'Territory', userTerritoriesService]);

    function userTerritoriesService ($q, $rootScope, userSessionService, Territory) {
        var service = {};

        service.getTerritories = getTerritories;
        service.getTerritoryBranches = getTerritoryBranches;

        function getTerritories () {
            var dfd = $q.defer();

            var currentUser = userSessionService.getUserInfo(true);

            currentUser.getList('territories')
                .then(function(response){
                    //console.log('get user territories: ',response.plain());
                    dfd.resolve(response.plain());
                }, function(error){
                    console.log('get user territories error: ', error);
                    dfd.reject(error);
                })

            return dfd.promise;
        }

        function getTerritoryBranches (territoryId) {
           var dfd = $q.defer();

            Territory.cast(territoryId)
               .getList('branches')
                    .then(function (response) {
                        //console.log('response: ', response.plain());
                        dfd.resolve(response.plain());
                    }, function (error) {
                        console.log('error: ', error);
                        dfd.reject(error);
                    });

            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('userSessionService', ['User', 'localStorageService', '$q', '$rootScope', userSessionService]);

    function userSessionService (User, localStorageService, $q, $rootScope) {
        var service = {};

        // user details
        var USER = 'USER';

        service.userLogin = userLogin;
        service.userLogout = userLogout;
        service.getUserInfo = getUserInfo;

        function userLogin () {
            if (!localStorageService.isSupported) return;

            var dfd = $q.defer();
            var currentUser = getUserInfo();

            if (currentUser) {
                dfd.resolve(currentUser);
            } else {
                User.customGET('current_user')
                    .then(function (response) {
                        localStorageService.set(USER, response.plain());
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function userLogout () {
            if (!localStorageService.isSupported) return;

            // clear all data on local storage on logout
            localStorageService.clearAll();
        }

        function getUserInfo (isRestangular) {
            if (!localStorageService.isSupported) return;

            var userObj = localStorageService.get(USER);

            return isRestangular ?
                            User.cast(userObj.id)
                            : userObj;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .factory('User', ['Restangular', User]);

    function User(Restangular) {
        var myModel = Restangular.all('users');

        var resource = {
            cast: function (userId) {
                return Restangular.restangularizeElement(null, {id: userId}, 'users');
            }
        };

        Restangular.extendModel('users', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('indexController', ['gmapServices', '$mdSidenav', indexController]);

    function indexController (gmapServices, $mdSidenav) {
        var vm = this;

        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        vm.lastSideNavOpenId = '';

        vm.showAddBranchModal = showAddBranchModal;

        initialize();

        function initialize() {
            gmapServices.createMap('map-canvas');
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }

                $mdSidenav(navID).toggle();

                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }

        function showAddBranchModal () {

        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('gmapController', [gmapController]);

    function gmapController() {

        //function showSolarDetailInfowindow (_solar) {
        //    if(!(_solar && _solar.id)) return;
        //
        //    solarGmapServices.hideSolarMarkers();
        //
        //    var defered = modalServices.showUpdateSolar(_solar, vm, event);
        //    defered.then(function (response) {
        //        console.log('modalServices.showUpdateSolar response:');
        //        console.log(response);
        //
        //            if (!response) return;
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //            if($rootScope.selectedSolar && response) {
        //                $rootScope.selectedSolar.coordinates = response.coordinates;
        //            }
        //        }, function (errorResponse) {
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //
        //            console.log('show update solar detail failed');
        //            console.log(errorResponse);
        //        });
        //}
        //
        //
        //function showMarkers () {
        //    solarGmapServices.showSolarMarkers();
        //    solarGmapServices.resetZoom();
        //}

        //function hideMarkers () {
        //    console.log('called from event : modal-opened');
        //    console.log('gmapcontroller hide markers');
        //    solarGmapServices.hideSolarMarkers();
        //    // Hide Solar List Table
        //    $rootScope.showSolarList = false;
        //}
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('branchService', ['Branch', 'gmapServices', '$rootScope', branchService]);

    function branchService (Branch, gmapServices, $rootScope) {
        var service = {};

        var branchMarkers = [],
            branchInfowindow;

        var branchIcons = {
            'mdc': 'branch-red.png',
            'lka': 'branch-green.png',
            'gt': 'branch-blue.png'
        };

        service.loadMarkers = loadMarkers;
        service.showMarkers = showMarkers;
        service.hideMarkers = hideMarkers;
        service.toggleMarkers = toggle;
        service.getBranchById = getBranchById;
        service.getRestangularObj = getRestangularObj;
        //service.closeInfoWindowById = closeInfoWindowById;

        function getBranchIconByType (type) {
            return '/images/markers/' + branchIcons[type.toLowerCase()];
        }

        function loadMarkers (list) {
            var marker;

            hideMarkers();
            branchMarkers = [];

            if (!branchInfowindow) branchInfowindow = gmapServices.createInfoWindow('');

            list.forEach(function (item) {
                marker = gmapServices.initMarker(item.latlng, getBranchIconByType(item.type));

                //marker.infowindow = gmapServices.createInfoWindow('');
                //marker.infowindow.branchId = item.id;

                marker.content = '<div>';
                marker.content += '<h3 class="no-margin padding-left-5"><b>' + item.name + '</b></h3>';
                marker.content += '<h4 class="no-margin text-muted padding-left-5">' + item.type + '</h4>';

                marker.content += '<button id="compare-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-primary">Compare</button>'

                if ($rootScope.currentUser.role === 'ADMIN') {
                    marker.content += '<button id="edit-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-default">Edit</button>';
                    marker.content += '<button id="delete-branch-btn" data-branch-id="' + item.id + '" class="md-button md-raised md-warn">Delete</button>';
                }

                marker.content += '</div>';

                marker.branch = angular.copy(item);
                marker.id = item.id;

                gmapServices.addListener(marker, 'click', function () {
                    //this.infowindow.open(gmapServices.map, this);
                    //this.infowindow.setContent(this.content);
                    branchInfowindow.open(gmapServices.map, this);
                    branchInfowindow.setContent(this.content);
                });

                //google.maps.event.addListener(marker.infowindow, 'closeclick', function () {
                //    console.log('infowindow close.!');
                //    // if current branch was added as compare then remove it on the table when infowindow closed
                //    $rootScope.$broadcast('branch-infowindow-closed', {id: this.branchId});
                //});

                branchMarkers.push(marker);
            });
        }

        function showMarkers() {
            branchMarkers.forEach(function (marker) {
                if (marker && !marker.getVisible()) marker.setVisible(true);
            });
        }

        function hideMarkers () {
            branchMarkers.forEach(function (marker) {
                if (marker && marker.getVisible()) marker.setVisible(false);
            });
        }

        function toggle () {
            if (branchMarkers.length) {
                if (branchMarkers[0].getVisible()) {
                    hideMarkers();
                } else {
                    showMarkers();
                }
            }
        }

        function getBranchById (branchId) {
            return _.findWhere(branchMarkers, {id: branchId});
        }

        function getRestangularObj(branchId) {
            return Branch.cast(branchId);
        }

        //function closeInfoWindowById(branchId) {
        //    var found = getBranchById(branchId);
        //    if (found) found.infowindow.close();
        //}

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('Branch', ['Restangular', Branch]);
    
    function Branch (Restangular) {
        var myModel = Restangular.all('branches');

        var resource = {
            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'branches');
            }
        };

        Restangular.extendModel('branches', function (model) {
            //model.deletePanel = function (panel_id) {
            //    return model
            //        .one('panels', panel_id)
            //        .remove();
            //};
            //
            //model.upload = function (_file, _caption) {
            //    var uploadUrl = model.getRestangularUrl() + '/' + 'photos',
            //        caption = _caption || '';
            //    return Upload.upload({
            //               url: uploadUrl,
            //               method: 'POST',
            //               data: {file: _file, caption: caption}
            //           });
            //};
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp', [
            'restangular',
            'LocalStorageModule',
            'ngMaterial',
            'ngAnimate',
            'oitozero.ngSweetAlert',
            'ngFileUpload',
            'md.data.table',
            'demoApp.home',
            'demoApp.admin',
            'demoApp.sales'
        ])

        .constant('APP_NAME', 'UNILAB')
        .constant('BASE_URL', window.location.origin)

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }])

        .config(["localStorageServiceProvider", function (localStorageServiceProvider) {
            localStorageServiceProvider
                .setPrefix('UNILAB')
                .setStorageType('sessionStorage')
                .setNotify(true, true)
            ;
        }])

        .run(["userSessionService", "$rootScope", function(userSessionService, $rootScope){
            userSessionService.userLogin()
                .then(function (user) {
                    $rootScope.currentUser = angular.copy(user);
                });
        }])

        //.config(function ($mdThemingProvider) {
        //    $mdThemingProvider.theme('default')
        //        .primaryPalette('red')
        //        .accentPalette('pink');
        //})
    ;

}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('placesService', ['Place', '$q', 'gmapServices', placesService]);

    function placesService (Place, $q, gmapServices) {
        var service = {};

        var iconByplaceTypes = {
            'hospital': {
                icon: 'hospital',
                color: '#f1c40f'
            },
            'airport': {
                icon: 'airport',
                color: '#3498db'
            },
            'bank': {
                icon: 'bank',
                color: '#f1c40f'
            },
            'lodging': {
                icon: 'lodging',
                color: '#16a085'
            },
            'school': {
                icon: 'school',
                color: '#7f8c8d'
            },
            'restaurant': {
                icon: 'restaurant',
                color: '#e67e22'
            },
            'shopping_mall': {
                icon: 'department-store',
                color: '#9b59b6'
            },
            'park': {
                icon: 'park',
                color: '#2ecc71'
            },
            'church': {
                icon: 'church',
                color: '#27ae60'
            },
            'museum': {
                icon: 'museum',
                color: '#95a5a6'
            },
            'cafe': {
                icon: 'cafe',
                color: '#f39c12'
            },
            'establishment': {
                icon: 'local-government',
                color: '#1abc9c'
            }
        };

        service.defaultPlaceTypes = [
            'hospital',
            'airport',
            'bank',
            'lodging',
            'school',
            'restaurant',
            'shopping_mall'
        ];

        var poiMarkers = [],
            poiInfowindow;

        service.loadPOIs = loadPOIs;
        service.showPOIs = showPOIs;
        service.showPOIByType = showPOIByType;
        service.hidePOIs = hidePOIs;
        service.getPlaceTypes = getPlaceTypes;

        function loadPOIs (territoryId) {
            var dfd = $q.defer();

            Place.get('', {types: 'hospital|clinic|schools|universities|shopping_mall', territoryid: territoryId})
                .then(function(response){
                    //console.log('places: ',response);
                    dfd.resolve(response.data);
                }, function(error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function showPOIs(data) {
            var marker,
                placeType;

             if (!poiInfowindow) poiInfowindow = gmapServices.createInfoWindow('');

            hidePOIs();

            poiMarkers = [];

            for (var poiType in data) {
                data[poiType].forEach(function (item) {
                    placeType = getPlaceIcon(item.type);
                    marker = gmapServices.createMapIconLabel(item.geometry.location, placeType.icon || 'compass', placeType.color);
                    marker.name = item.name;
                    marker.type = item.type;
                    marker.content = '<b>' + item.name + '</b>';
                    marker.content += '<br>' + marker.type;

                    gmapServices.addListener(marker, 'click', function () {
                        poiInfowindow.open(gmapServices.map, this);
                        poiInfowindow.setContent(this.content);
                    });

                    poiMarkers.push(marker);
                });
            }
        }

        function showPOIByType(type) {
            if (type == 'all') {
                poiMarkers.forEach(function (marker) {
                    if (!marker.getVisible()) marker.setVisible(true);
                });
                return;
            }

            poiMarkers.forEach(function (marker) {
                if (type != marker.type) {
                    marker.setVisible(false);
                    return;
                }

                if (!marker.getVisible()) marker.setVisible(true);
            })
        }

        function hidePOIs() {
            poiMarkers.forEach(function (marker) {
                if (marker && marker.getVisible()) marker.setVisible(false);
            });
        }

        function getPlaceTypes() {
            var result = [];
            for (var key in iconByplaceTypes) {
                result.push(key);
            }
            return result;
        }

        function getPlaceIcon(placeType) {
            return iconByplaceTypes[placeType];
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Place', ['Restangular', Place]);

    function Place(Restangular) {
        var myModel = Restangular.all('places');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'places');
            }
        };

        Restangular.extendModel('places', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            return Restangular.stripRestangular(model);
            //return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        //var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        //var addProjectModal,
        //    projectDetailModal
        //;

        /* Service Functions */
        //service.showAddProject = showAddProject;
        //service.showProjectDetail = showProjectDetail;
        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        //function showAddProject(ev, _position) {
        //    var opts = {
        //        controller: 'addProjectController',
        //        controllerAs: 'vm',
        //        templateUrl: '/partials/modals/_add-project.tmpl.html',
        //        parent: angular.element(document.querySelector('#admin-container')),
        //        targetEvent: ev,
        //        hasBackdrop: false,
        //        locals: {position: _position},
        //        fullscreen: $mdMedia('xs'),
        //        onComplete: function (scope, element, options) {
        //            $('.md-scroll-mask').css('z-index', '-1');
        //        }
        //    };
        //
        //    return showModal(addProjectModal, opts);
        //}
        //
        //function showProjectDetail(proj) {
        //    var opts = {
        //        controller: 'projectDetailsController',
        //        controllerAs: 'vm',
        //        templateUrl: '/partials/modals/_view-project.tmpl.html',
        //        parent: angular.element(document.querySelector('#admin-container')),
        //        hasBackdrop: false,
        //        locals: {project: proj},
        //        fullscreen: $mdMedia('xs'),
        //        onComplete: function (scope, element, options) {
        //            $('.md-scroll-mask').css('z-index', '-1');
        //        }
        //    };
        //    return showModal(projectDetailModal, opts);
        //}

        function hideResolveModal(response) {
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('mainController', ['$rootScope', 'APP_NAME', '$mdSidenav', 'userSessionService', 'alertServices', 'branchService', mainController]);

    function mainController($rootScope, APP_NAME, $mdSidenav, userSessionService, alertServices, branchService) {
        var vm = this;

        $rootScope.appName = APP_NAME;

        /* Side Nav Menus */
        vm.menu = [];

        var MENU_SELECTIONS = [
            {
                link: '/',
                title: 'Home',
                icon: 'home',
                can: ['ADMIN', 'SALES']
            },
            {
                link: '/admin',
                title: 'Admin',
                icon: 'contacts',
                can: ['ADMIN']
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app',
                can: ['ADMIN', 'SALES']
            }
        ];

        var branchId,
            branchMarker;

        $rootScope.showBranchCompareTable = false;

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');
        vm.onMenuItemClick = onMenuItemClick;
        vm.showBanchCompareTableAction = showBanchCompareTableAction;

        initialize();

        function initialize () {
            // loads user details
            //userSessionService.userLogin()
            //    .then(function(user){
            //       $rootScope.currentUser = angular.copy(user);
            //       vm.menu = getUserMenu(user);
            //    });
            $rootScope.$watch('currentUser', function(newValue, oldValue){
                if (!newValue) return;

                vm.menu = getUserMenu(newValue);
            });

            // Compare Branch
            $(document).on('click', '#compare-branch-btn', function () {
                branchId = $(this).data('branch-id');
                branchMarker = branchService.getBranchById(branchId);

                if (branchMarker) {
                    $rootScope.$broadcast('close-territory-info-panel');

                    var restObj = branchService.getRestangularObj(branchMarker.branch.id);

                    // get branch products
                    restObj.getList('products')
                        .then(function(response){
                            branchMarker.branch.products = angular.copy(response.plain());
                            $rootScope.$broadcast('new-compare-branch', branchMarker.branch);
                        });
                }
            });

            // Edit Branch
            $(document).on('click', '#edit-branch-btn', function () {
                branchId = $(this).data('branch-id');
                console.log('edit branch with id = ' + branchId);
                // TODO: show edit modal
                branchMarker = branchService.getBranchById(branchId);
                console.log('compare this branch: ', branchMarker);
            });

            // Delete Branch
            $(document).on('click', '#delete-branch-btn', function () {
                branchId = $(this).data('branch-id');

                alertServices.showConfirm('Delete Branch', 'Are your sure you want to delete this branch?', function (isConfirm) {
                    // TODO: ajax delete on confirm
                    if (isConfirm) alert('branch deleted!');
                })
            });
        }

        function getUserMenu (user) {
            // TODO: this must come from backend
            var result = [];

            MENU_SELECTIONS.forEach(function(item){
                if (item.can.indexOf(user.role.toUpperCase()) > -1) return result.push(item);
            });

            return result;
        }

        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle();
            }
        }

        function onMenuItemClick (item) {
            if (item.title.toLowerCase() == 'logout') {
                // clean local storage
                userSessionService.userLogout();
            }

            window.location.href = item.link;
        }

        function showBanchCompareTableAction () {
            $rootScope.showBranchCompareTable = true;
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(10.3194669, 123.9136565);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.createMapIconLabel = createMapIconLabel;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            //$(myMapId).height($(window).height() - (42));
            $(myMapId).height($(window).height());

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //service.geocoder = new google.maps.Geocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if (!(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function (infobox, index) {
                if (infobox) {
                    infobox.close();
                }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            var marker = service.initMarker(_position, _color);

            //service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            return service.initMarker(_position, icon);
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if (_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else {
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function createCircle(centerLatLng, radiusParam, color) {
            return new google.maps.Circle({
                strokeColor: color || '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: color || '#FF0000',
                fillOpacity: 0.35,
                map: service.map,
                center: centerLatLng,
                radius: radiusParam
            });
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.map.setCenter(bounds.getCenter());
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if (layerName == 'meters') {
                return defaultStyle;
            } else if (layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if (layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation(latLng, polygon) {
            if (!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent(obj, event) {
            google.maps.event.trigger(obj, 'click');
        }

        function createMapIconLabel(latLng, type, color) {
            console.log('createMapIconLabel: ',latLng, type, color);
            return new Marker({
                map: service.map,
                position: latLng,
                icon: {
                    anchor: new google.maps.Point(-6, -10),
                    path: MAP_PIN,
                    fillColor: color || '#2ecc71',
                    fillOpacity: 1,
                    strokeColor: color ? '' : '#27ae60',
                    strokeWeight: color ? 0 : 1
                },
                map_icon_label: '<span class="map-icon map-icon-' + type + '"></span>'
            });
        }

        service.createFacilityMarker = createFacilityMarker;

        function createFacilityMarker(latLng) {
            return service.initMarker(latLng, 'resources/images/markers/wifi.png');
        }

        return service;
    }
}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Boundary', ['Restangular', Boundary]);

    function Boundary(Restangular) {
        var myModel = Restangular.all('boundaries');

        var resource = {
            cast: function (myId) {
                return Restangular.restangularizeElement(null, {id: myId}, 'boundaries');
            }
        };

        Restangular.extendModel('boundaries', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('boundariesService', ['Boundary', '$q', boundariesService]);

    function boundariesService (Boundary, $q) {
        var service = {};

        service.boundaries = [];

        service.loadBoundaries = loadBoundaries;
        service.getRestangularObj = getRestangularObj;

        function loadBoundaries(parentid) {
            var dfd = $q.defer();

            Boundary.customGET(null, {parent_id: parentid || null})
                .then(function (list) {
                    //console.log('load boundaries: ', list);
                    service.boundaries = list.plain().map(function (item) {
                        item['isExpanded'] = false;
                        return item;
                    });

                    dfd.resolve(list.plain());
                }, function (error) {
                    console.log('failed to load: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getRestangularObj (boundaryId) {
            return Boundary.cast(boundaryId);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        //service.showFilterSelectionEmpty = showFilterSelectionEmpty;
        service.showConfirm = showConfirm;

        function showToast(message, position) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(2000)
            );
        }

        function showBottomLeftToast(message) {
            showToast(message, 'bottom left');
        }

        function showTopRightToast(message) {
            showToast(message, 'top right');
        }

        function showMessage(message, type) {
            SweetAlert.swal({
                title: message,
                type: type
            });
        }

        function showNoDataAvailablePrompt(entityName) {
            service.showBottomLeftToast('No ' + entityName + ' data available for this area.');
        }

        function showConfirm (title, message, callbackOnConfirm) {
            SweetAlert.swal({
                    title: title,
                    text: message,
                    type: "warning",
                    showCancelButton: true,
                    confirmButtonColor: "#DD6B55",
                    confirmButtonText: "Yes",
                    closeOnConfirm: true
                },
                callbackOnConfirm);
        }



        //function showFilterSelectionEmpty() {
        //    showMessage('Please select filter type.', 'warning');
        //}
        //
        //function showQueryIsEmpty() {
        //    showMessage('Please fill in search query.', 'info');
        //}

        return service;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.admin', []);

}());

(function(){
'use strict';

angular.module('demoApp.admin')
    .controller('adminPanelController', ['$rootScope', 'boundariesService', 'branchService', 'userTerritoriesService', '$timeout', 'gmapServices', '$q', 'alertServices', adminPanelController]);

    function adminPanelController ($rootScope, boundariesService, branchService, userTerritoriesService, $timeout, gmapServices, $q, alertServices) {
        var vm = this;

        var polygonObj;

        vm.boundaries = [];
        vm.territories = [];
        vm.showTerritoriesPanel = false;

        vm.expandCallback = expandCallback;
        vm.showBoundary = showBoundary;
        vm.showTerritory = showTerritory;

        initialize();

        function initialize () {
            boundariesService.loadBoundaries()
                .then(function (list) {
                    vm.boundaries = angular.copy(list);
                }, function (error) {
                    console.log('failed to load: ', error);
                });

            $rootScope.$watch('currentUser', function (newValue, oldValue) {
                if (!newValue) return;

                userTerritoriesService.getTerritories()
                    .then(function (territories) {
                        vm.territories = _.uniq(territories, true, function (item) {
                            return item.territoryid;
                        });
                    });
            });
        }

        function showPolygon(latLngArray, isTerritory) {
            if (polygonObj) {
                polygonObj.setPath(latLngArray);
            } else {
                polygonObj = gmapServices.createPolygon(latLngArray);
            }

            var color = isTerritory ? '#3f51b5' : '#ff0000';

            polygonObj.setOptions({
                fillColor: color,
                strokeColor: color
            });
        }

        function showBoundary(brgy) {
            var item = boundariesService.getRestangularObj(brgy.id);

            $('md-list-item#' + item.id.toString() + ' md-progress-circular').show();

            var boundaryDataResponse,
                boundaryBranchesResponse;

            var dfd1 = item.get()
                .then(function (response) {
                    boundaryDataResponse = response.plain();
                    //console.log('get boundary detail: ', boundaryDataResponse);
                });

            var dfd2 = item.getList('branches')
                    .then(function(response){
                        boundaryBranchesResponse = response.plain();
                        //console.log('get branches within boundary: ', boundaryBranchesResponse);
                    });


            $q.all([dfd1, dfd2])
                .then(function(){
                    showPolygon(boundaryDataResponse.geometry);
                    gmapServices.setZoomIfGreater(14);
                    gmapServices.panToPolygon(polygonObj);

                    branchService.loadMarkers(boundaryBranchesResponse.map(function(item){ return item.branch; }));
                })
                .finally(function () {

                    $timeout(function () {
                        $('md-list-item#' + item.id.toString() + ' md-progress-circular').hide();
                    }, 1000);

                    // show pois on map
                    //boundariesService.showPOIs(response.places, item);
                    //boundariesService.loadDPs(response.facilities);
                    //$mdSidenav('boundariesInfoSidenav').open();
                });
        }

        function expandCallback(item, event) {
            event.stopPropagation();

            if (item.isExpanded === false) return;

            if (item.typeid < 7) {
                if (item.hasOwnProperty('children') && item.children.length) return;

                $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').show();

                item.children = [];

                $('v-pane#' + item.id.toString() + ' v-pane-content v-accordion').children().html('');

                boundariesService.loadBoundaries(item.id)
                    .then(function (list) {
                        if (list.length) item.children = angular.copy(list);
                    }, function (error) {
                        console.log('failed to load: ', error);
                    })
                    .finally(function () {
                        $timeout(function () {
                            $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').hide();
                        }, 1000);
                    });

                return;
            }

            showBoundary(item);

            return;
        }

        function showTerritory (item) {
            $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').show();

            console.log('showTerritory: ',item);
            //$rootScope.selectedTerritory = item;


            // load places
            // TODO: uncomment this after working on other features to avoid gmap credits toll
            //var dfd1 = placesService.loadPOIs(item.territoryid)
            //            .then(function(response){
            //                placesService.showPOIs(response);
            //                $rootScope.selectedTerritory.places = response;
            //            });

            var dfd2 = userTerritoriesService.getTerritoryBranches(item.territoryid)
                .then(function (response) {
                    console.log('getTerritoryBranches: ', response);

                    if (!response.length) {
                        alertServices.showBottomLeftToast('This territory doesnt have branch yet.');
                        return;
                    }

                    branchService.loadMarkers(response);
                });

            $q.all([dfd2])
                .then(function () {
            //        $mdSidenav('territoryInfoPanelSidenav').open();
            //        $rootScope.$broadcast('territory_selected', $rootScope.selectedTerritory);
                })
                .finally(function(){
                    showPolygon(item.territory.geom, true);
                    gmapServices.setZoomIfGreater(10);
                    gmapServices.panToPolygon(polygonObj);

                    $('md-list-item#territory-' + item.territoryid + ' .md-list-item-text md-progress-circular').hide();
                });
        }

    }
}());